<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[linux命令性能监控及优化]]></title>
      <url>/2018/01/30/linux%E5%91%BD%E4%BB%A4%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[linux常用命令]]></title>
      <url>/2018/01/30/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>没什么可说的，当前不知道处于那个目录下时，<a href="http://www.cnblogs.com/peida/archive/2012/10/24/2737730.html" target="_blank" rel="noopener">pwd</a>即可</p>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p><a href="http://www.cnblogs.com/peida/archive/2012/10/27/2743022.html" target="_blank" rel="noopener">mv</a>命令是将一个文件移动到指定的目录，但是在linux可以用来重命名文件</p>
<h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p><a href="http://www.cnblogs.com/peida/archive/2012/11/02/2750588.html" target="_blank" rel="noopener">more</a>是具有翻页功能的<a href="http://www.cnblogs.com/peida/archive/2012/10/30/2746968.html" target="_blank" rel="noopener">cat</a>命令</p>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p><a href="http://www.cnblogs.com/peida/archive/2012/11/05/2754477.html" target="_blank" rel="noopener">less</a>是一个可以前后分页浏览文件的命令，相比more更加具有弹性</p>
<h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p><a href="http://www.cnblogs.com/peida/archive/2012/11/09/2761928.html" target="_blank" rel="noopener">which</a>用于查找命令包所在的路径，没有配置在环境变量中的命令是搜索不到的，因为which只会搜索path下的命令，echo $PATH可以查看</p>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>ls命令还是很常用的，不做过多描述<br><br>ls g* 模糊列出文件列表，即将g开头的文件列出</p>
<h2 id="unzip和gzip"><a href="#unzip和gzip" class="headerlink" title="unzip和gzip"></a>unzip和gzip</h2><p>unzip主要用于解压.zip压缩文件 unzip xxx.zip<br><br>gzip file1 file2 … 文件打包压缩为.gz的形式<br><br>对于文件夹的打包或者其他的压缩格式请使用tar命令</p>
<h2 id="whatis和man"><a href="#whatis和man" class="headerlink" title="whatis和man"></a>whatis和man</h2><p>$whatis command 用于显示命令使用的描述<br><br>$man command 以使用手册的形式显示</p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux命令 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务问题定位——jmap]]></title>
      <url>/2018/01/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94jmap/</url>
      <content type="html"><![CDATA[<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>内存溢出，线上程序运行时内存越来越大，用jmap dump出堆内存的信息，然后进行相关分析</li>
<li>内存的真实使用大于预期，这是因为设计不合理导致冗余的对象存在内存中，用jmap来查看内存中的对象，分析是否有存在的必要</li>
<li>jvm优化，利用jmap来查看整个堆的使用情况，根据老年代和新生代的使用比例来划分jvm的各个区域</li>
</ul>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>在使用jmap连接进程时，启动的jvm版本和jdk版本要一一对应，毕竟jmap是jdk下的命令包<br><br>$ps -ef | grep java 查找系统的java进程<br><br>$jmap -heap pid 打印指定进程堆的摘要信息，包括gc算法<br><br><img src="https://raw.githubusercontent.com/yunchangwang/blogs/master/jmap/jmap.jpg" alt="例图"><br></p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul>
<li>Heap Configuration:  <strong>堆配置信息</strong><blockquote>
<p>MinHeapFreeRatio   <strong>在堆的使用率小于MinHeapFreeRatio(%)的时候进行收缩，当Xmx=Xms的时候此配置无效</strong><br>MaxHeapFreeRatio  <strong>在堆使用率大于MaxHeapFreeRatio(%)的时候进行扩展，当Xmx=Xms的时候此配置无效</strong><br>MaxHeapSize   <strong>堆的最大空间</strong><br>NewSize  <strong>新生代的大小</strong><br>MaxNewSize   <strong>最大的新生代的大小</strong><br>OldSize   <strong>老年代的大小</strong><br>NewRatio   <strong>新生代中Eden和Survivor区的比例</strong><br>SurvivorRatio   <strong>新生代中Eden和和Survivor区的比例</strong><br>PermSize   <strong>永久代的大小</strong><br>MaxPermSize     <strong>久代的最大内存</strong><br>G1HeapRegionSize    <strong>使用G1垃圾收集的区间</strong></p>
</blockquote>
</li>
<li>Heap Usage:   <strong>堆的使用信息</strong></li>
<li>New Generation (Eden + 1 Survivor Space):   <strong>新生代的大小（Eden区加一个Survivor区的空间信息</strong><blockquote>
<blockquote>
<p>capacity  <strong>总内存</strong><br>used  <strong>已使用内存</strong><br>free   <strong>剩余内存</strong><br>13.823827124993642% used     <strong>使用内存占比</strong></p>
</blockquote>
</blockquote>
</li>
<li>Eden Space:   <strong>Eden区的大小</strong><blockquote>
<blockquote>
<p>capacity<br>used<br>free<br>15.178337946947952% used</p>
</blockquote>
</blockquote>
</li>
<li>From Space:   <strong>第一个Surivivor区的空间信息</strong><blockquote>
<blockquote>
<p>capacity<br>used<br>free<br>2.984432830624237% used</p>
</blockquote>
</blockquote>
</li>
<li>To Space:   <strong>第二个Survivor区的空间信息</strong><blockquote>
<blockquote>
<p>capacity<br>used<br>free<br>0.0% used</p>
</blockquote>
</blockquote>
</li>
<li>concurrent mark-sweep generation:   <strong>CMS垃圾收集占用的空间信息</strong><blockquote>
<blockquote>
<p>capacity<br>used<br>free<br>75.36470666527748% used</p>
</blockquote>
</blockquote>
</li>
<li>Perm Generation:   <strong>永久代的空间信息</strong><blockquote>
<blockquote>
<p>capacity<br>used<br>free<br>47.5915253162384% used</p>
</blockquote>
</blockquote>
</li>
</ul>
<h4 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h4><p><a href="http://guochenglai.com/2016/07/15/java-command3-jmap/" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      
        <categories>
            
            <category> 微服务问题定位 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务问题定位——jstack]]></title>
      <url>/2018/01/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94jstack/</url>
      <content type="html"><![CDATA[<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>查看运用程序jvm的堆栈情况，可以找出线程的运行情况，从而排查一些隐患或者服务卡顿的问题</p>
<h3 id="具体说明"><a href="#具体说明" class="headerlink" title="具体说明"></a>具体说明</h3><p>jstack用于打印出给定的java进程id或者core file或者远程调试服务的java堆栈信息，如果是在64位机器上，需要指定选项-J-d64<br><br>如果java程序崩溃会生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松知道java程序是如何崩溃和在程序何处发生问题。</p>
<h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><p>-F 当jstack -l pid 没有响应的时候强制打印栈信息<br><br>-l 长队列，打印关于锁的附加信息<br><br>-m 打印java和native c/c++框架的所有栈信息<br></p>
<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><p>jstack [option] pid<br><br>jstack [option] executable core<br><br>jstack [option] [server-id@]remote-hostname-or-IP</p>
<h3 id="命令格式说明"><a href="#命令格式说明" class="headerlink" title="命令格式说明"></a>命令格式说明</h3><p>executable core 产生core dump的java可执行文件<br><br>remote-hostname-or-IP 远程debug服务的主机名或ip<br><br>server-id 唯一id,假如一台主机上多个远程debug服务</p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>一般需要与<a href="https://yunchangwang.github.io/2018/01/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94top/#more" target="_blank" rel="noopener">top</a>命令联用，使用top命令找出异常的进程(<strong>一般是cpu使用异常的进程</strong>)<br><br>通过top -Hp pid来定位该进程下各线程的cpu使用情况<br><br>再通过jstack pid命令打印该线程对应的堆栈情况</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul>
<li>在top命令中，已经获取到了占用cpu资源较高的线程pid，将该pid转成16进制的值(<strong><a href="https://tool.lu/hexconvert/" target="_blank" rel="noopener">在线转换</a></strong>)，在thread dump中每个线程都有一个nid，找到对应的nid即可<br></li>
<li>什么是java core和heap dump文件，<a href="http://www.cnblogs.com/jingmoxukong/p/5509196.html" target="_blank" rel="noopener">参考</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 微服务问题定位 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gitbook目录折叠]]></title>
      <url>/2018/01/28/gitbook%E7%9B%AE%E5%BD%95%E6%8A%98%E5%8F%A0/</url>
      <content type="html"><![CDATA[<h2 id="gitbook目录折叠"><a href="#gitbook目录折叠" class="headerlink" title="gitbook目录折叠"></a>gitbook目录折叠</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在编写gitbook的时候发现目录的数量比较庞大的时候显得杂乱无章<br><br>因为章节比较多的时候全展开，很难有目的地寻找<br><br>所以笔者去寻求了解决之道，用来折叠目录，笔者在网上找到了一个插件可以解决这个问题</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a href="http://www.chengweiyang.cn/gitbook/plugins/functional/toggle-chapters.html" target="_blank" rel="noopener">插件网站</a><br><br>上面还有其他gitbook使用的插件<br></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><a href="http://www.chengweiyang.cn/gitbook/customize/book.json.html" target="_blank" rel="noopener">参考</a><br><br>个性化配置gitbook，同理你可以在里面添加需要使用的插件，如图<br><br><img src="https://raw.githubusercontent.com/yunchangwang/blogs/master/gitbook/plugin.jpg" alt="样图"><br><br>book.json在根目录下，即与SUMMARY.md同级<br><br>$ cd到gitbook目录<br><br>$ npm install gitbook-plugin-toggle-chapters<br><br>重新build  serve即可</p>
]]></content>
      
        <categories>
            
            <category> gitbook </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gitbook </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在本地搭建gitbook]]></title>
      <url>/2018/01/28/%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAgitbook/</url>
      <content type="html"><![CDATA[<h2 id="本地搭建gitbook"><a href="#本地搭建gitbook" class="headerlink" title="本地搭建gitbook"></a>本地搭建gitbook</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>gitbook更加适用于书写使用手册，不太适合书写一些博客和总结，所以笔者最近在做一些迁移的工作，将之前gitbook上的内容迁移到当前的博客上<br><br>但是gitbook对于我们的工作还是有适用的地方的</p>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>安装nodejs是先决条件，因为我们需要npm去下载gitbook<br><br>在mac电脑上，有brew工具的可以直接下载:<br><br>$brew search nodejs 搜索包仓库中是否有nodejs<br><br>$brew install nodejs 有就可以直接下载<br><br>你也可以选择去官网上下载最新的nodejs压缩包，解压配置环境变量后即可使用<br></p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>这里默认大家的电脑上已经安装好了nodejs<br><br>按照步骤执行以下命令:<br><br>$npm install gitbook-cli -g  下载gitbook客户端包<br><br>$gitbook –version  查看gitbook的版本，测试是否可以使用命令<br><br>$cd /users/Desktop 切换到一个目录，这里笔者切换到了桌面<br><br>$mkdir gitbook  创建gitbook目录，这个目录就是用来初始化的<br><br>其实上面的两步读者可以手动完成<br><br>$gitbook init  初始化gitbook<br><br>$gitbook build  构建，一般有内容更新时要构建<br><br>$gitbook serve  开启服务，默认在4000端口监听<br><br><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>  开启你的访问之路吧！</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>笔者之前在windows上搭建过，出现了一些问题，build的时候总是报错<br><br>在github官方issues中，官方表示这个是已知的gitbook的bug，高版本的gitbook会出现这个bug<br><br>如果你遇到相同的问题，请参考:<br><a href="https://github.com/GitbookIO/gitbook/issues/1309" target="_blank" rel="noopener">解决方法</a><br><br>解决方法是点赞和喝彩最多的</p>
]]></content>
      
        <categories>
            
            <category> gitbook </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gitbook </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务问题定位——du]]></title>
      <url>/2018/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94du/</url>
      <content type="html"><![CDATA[<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>du命令也是查看使用空间的，但是与df命令不同的是 du命令是对文件和目录磁盘使用的空间的查看</p>
<h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><p>-a或-all  显示目录中个别文件的大小<br><br>-b或-bytes  显示目录或文件大小时，以byte为单位<br><br>-c或–total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和<br><br>-k或–kilobytes  以KB(1024bytes)为单位输出<br><br>-m或–megabytes  以MB为单位输出<br><br>-s或–summarize  仅显示总计，只列出最后加总的值<br><br>-h或–human-readable  以K，M，G为单位，提高信息的可读性<br><br>-x或–one-file-xystem  以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过<br><br>-L&lt;符号链接&gt;或–dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小<br><br>-S或–separate-dirs   显示个别目录的大小时，并不含其子目录的大小<br><br>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt;  在&lt;文件&gt;指定目录或文件<br><br>–exclude=&lt;目录或文件&gt;         略过指定的目录或文件<br><br>-D或–dereference-args   显示指定符号链接的源文件大小<br><br>-H或–si  与-h参数相同，但是K，M，G是以1000为换算单位<br><br>-l或–count-links   重复计算硬件链接的文件<br></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>$du 显示当前目录下面子目录的目录大小和总和<br><br>$du dir/filename 显示指定目录或者文件<br><br>$du #1 #2 同时显示多个，空格隔开<br></p>
]]></content>
      
        <categories>
            
            <category> 微服务问题定位 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux命令 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 磁盘 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务问题定位——df]]></title>
      <url>/2018/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94df/</url>
      <content type="html"><![CDATA[<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>用来检查服务器文件系统的磁盘空间占用情况，可以获取硬盘被占了多少空间，目前还剩下多少空间等信息</p>
<h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><p>-a 全部文件系统列表<br><br>-h 方便查阅方式显示<br><br>-H 等-h，但是计数方式变更，1k=1000<br><br>-i 显示node信息<br><br>-k 区块为1024字节<br><br>-l 只显示本地文件系统<br><br>-m 区块为1048576字节<br><br>–no-sync 忽略sync命令<br><br>-P 输出格式为POSIX<br><br>–sync 在取得磁盘信息前先执行sync命令<br><br>-T 文件系统类型<br></p>
<h4 id="选择参数"><a href="#选择参数" class="headerlink" title="选择参数"></a>选择参数</h4><p>–block-size=&lt;区块大小&gt; 指定区块的大小<br><br>-t &lt;文件系统类型&gt; 只显示选定文件系统的磁盘信息<br><br>-x &lt;文件系统类型&gt; 不显示选定文件系统的磁盘信息<br></p>
<h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p><img src="https://raw.githubusercontent.com/yunchangwang/blogs/master/df/df.jpg" alt="例图"><br>第一列 显示各文件系统<br><br>第二列 显示文件系统的块数 这里以512B为一块<br><br>第三列 显示已经使用的磁盘<br><br>第四列 显示可用的磁盘<br><br><a href="http://www.cnblogs.com/peida/archive/2012/12/07/2806483.html" target="_blank" rel="noopener">其他</a><br><br>这边需要说明：已使用的+可使用的 != 总块数，因为缺省的每个分区都预留了少量空间供管理员使用，所以即使普通用户的空间已满，管理员依然可以登录系统解决相关问题</p>
]]></content>
      
        <categories>
            
            <category> 微服务问题定位 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux命令 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 磁盘 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务问题定位——ifstat]]></title>
      <url>/2018/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94ifstat/</url>
      <content type="html"><![CDATA[<h2 id="ifstat"><a href="#ifstat" class="headerlink" title="ifstat"></a>ifstat</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>监控系统的流量问题</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>ifstat不是系统自带的命令，所以需要进行安装，笔者这里只介绍mac上如何安装<br><br>$brew install ifstat<br><br>当然这边brew要自行安装</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>-l 监测环路网络接口(lo)，缺省情况下不会显示，所谓的环路网络可认为是localhost(127.0.0.1)<a href="https://www.zhihu.com/question/23940717" target="_blank" rel="noopener">参考</a><br><br>-a 监测系统所有的网络，比加上-l参数还多一个plip0的接口信息(所谓的并口)<br><br>-z 隐藏流量是无的接口，排查问题时排除无用端口<br><br>-i 指定要监测的接口,后面跟网络接口名<br><br>-s 等于加-d snmp:[comm@][#]host[/nn]] 参数，通过SNMP查询一个远程主机<br><br>-t 在每一行的开头加一个时间 戳,，告诉我们具体的时间<br><br>-T 报告所有监测接口的全部带宽，和-i联用来指定端口<br><br>-S 在同一行更新流量状态，不喜欢屏幕滚动的可以使用<br><br><a href="http://man.linuxde.net/ifstat" target="_blank" rel="noopener">其他命令</a></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>如何只查看网卡的流量情况，ifstat足矣<br><br>详细的流量情况需使用iftop命令，系统依旧不会自带需要下载，mac下载方式与ifstat一致<br><br>可以查看恶意请求流量的ip地址，并进行相关防护措施<br><br><a href="http://www.3mu.me/linux%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7iftop%E6%9F%A5%E7%9C%8B%E5%B8%A6%E5%AE%BD%E6%B5%81%E9%87%8F%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">实例参考</a></p>
]]></content>
      
        <categories>
            
            <category> 微服务问题定位 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux命令 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务问题定位——free]]></title>
      <url>/2018/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94free/</url>
      <content type="html"><![CDATA[<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>   显示系统使用和空闲的内存情况，包括物理内存和交互区内存(swap)和内核缓冲区内存</p>
<h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><p>   -b  以Byte为单位显示内存使用情况<br><br>   -k  以KB为单位显示内存使用情况<br><br>   -m  以MB为单位显示内存使用情况<br><br>   -g  以GB为单位显示内存使用情况<br><br>   -o 不显示缓冲区调节列<br><br>   -s&lt;间隔秒数&gt; 持续观察内存使用状况<br><br>   -t 显示内存总和列<br><br>   -V 显示版本信息</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>   <img src="https://raw.githubusercontent.com/yunchangwang/blogs/master/free/swap.png" alt="图片"><br><br>   这边关注第二行的<strong>swap的used指标</strong>，如果使用的值较大，则表示系统的内存处于不够使用的情况</p>
<h3 id="为何swap-used是一个指标"><a href="#为何swap-used是一个指标" class="headerlink" title="为何swap used是一个指标"></a>为何swap used是一个指标</h3><p>   <strong>swap</strong>又称为交换分区，当系统的内存小于<strong>额定值</strong>的时候，内核(OS)会将系统的一部分物理内存释放出来用于当前线程的使用，一般是很久没有操作过的程序会被释放，<strong>释放的物理内存被放入到交换区</strong>，然后等当前线程执行完毕，内存富余时重新放入物理内存</p>
]]></content>
      
        <categories>
            
            <category> 微服务问题定位 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux命令 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 内存相关 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务问题定位——strace]]></title>
      <url>/2018/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94strace/</url>
      <content type="html"><![CDATA[<h2 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h2><p><strong>以下说明都是基于docker系统机器实验</strong></p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>   系统调用和信号传递的跟踪</p>
<h3 id="option参数"><a href="#option参数" class="headerlink" title="option参数"></a>option参数</h3><p>   -c  统计每一系统调用的所执行的时间,次数和出错的次数等<br><br>   -d  输出strace关于标准错误的调试信息<br><br>   -f  跟踪由fork调用所产生的子进程<br><br>   -tt  在输出中的每一行前加上时间信息,微秒级， 时间格式：17:22:58.345879<br><br>   -p pid 跟踪指定的进程pid<br><br>   <strong><em>以上命令一般都是与-p联用</em></strong></p>
<h3 id="strace的命令使用比较复杂，不做详细说明"><a href="#strace的命令使用比较复杂，不做详细说明" class="headerlink" title="strace的命令使用比较复杂，不做详细说明"></a>strace的命令使用比较复杂，不做详细说明</h3><p>   在此贴出网上的一些参考链接<br><br>   <a href="https://leokongwq.github.io/2016/10/15/strace-learn.html" target="_blank" rel="noopener">strace实例</a><br><br>   <a href="http://www.cnblogs.com/kongzhongqijing/articles/4913192.html" target="_blank" rel="noopener">strace实例2</a><br></p>
<h3 id="样例贴图"><a href="#样例贴图" class="headerlink" title="样例贴图"></a>样例贴图</h3><p>   <strong>从缺</strong></p>
]]></content>
      
        <categories>
            
            <category> 微服务问题定位 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux命令 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 进程,线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微服务问题定位——top]]></title>
      <url>/2018/01/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94top/</url>
      <content type="html"><![CDATA[<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>显示当前系统正在执行的进程的相关信息，包括进程ID、 内存占用率 、CPU占用率等</p>
<h3 id="option-使用参数"><a href="#option-使用参数" class="headerlink" title="option 使用参数"></a>option 使用参数</h3><p>-b 进入批处理模式  <strong>相当于不停地执行top命令显示信息</strong><br><br>-c 显示完整的command <strong>位于信息的最后一列</strong><br><br>-i &lt;时间&gt; 设置间隔时间 <br><br>-u &lt;用户名&gt; 显示指定用户的信息 <br><br>-p &lt;进程号&gt; 显示指定进程的信息 <br><br>-n &lt;次数&gt; 循环显示的次数 <br><br>…</p>
<h3 id="例图"><a href="#例图" class="headerlink" title="例图"></a>例图</h3><p><img src="https://raw.githubusercontent.com/yunchangwang/blogs/master/top/top.jpg" alt="top信息截图"></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>  *第一行:</p>
<blockquote>
<p>13:40:29 — 当前系统时间<br><br>10 day,2:32 — 机器从开机到目前为止运行的时长<br><br>20 users — 登陆的用户有20个<br><br>load average — 分别对应1mins,5mins,15mins的负载情况(<strong>根据一定的算法得到的值，load average／cpu数量&gt;=5说明系统超负荷</strong>)</p>
</blockquote>
<p>  *第二行</p>
<blockquote>
<p>Tasks total — 当前系统进程269个<br><br>running — 正在运行的1个<br><br>sleeping — 睡眠的268个<br><br>stopped — 停止的0个<br><br>zombie — 僵尸进程0个<br></p>
</blockquote>
<p>  *第三行</p>
<blockquote>
<p>0.1%us — 用户空间占用CPU的百分比。<br><br>0.0% sy — 内核空间占用CPU的百分比。<br><br>0.0% ni — 改变过优先级的进程占用CPU的百分比<br><br>99.9% id — 空闲CPU百分比<br><br>0.0% wa — IO等待占用CPU的百分比<br><br>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比<br><br>0.0% si — 软中断（Software Interrupts）占用CPU的百分比<br></p>
</blockquote>
<p>  *第四行</p>
<blockquote>
<p>Mem total — 物理内存总量 8GB<br><br>free — 空闲的内存 <br><br>used — 正在使用的内存<br><br>buff/cache — 缓存的内存<br><br>(<strong>used表示现在系统内核控制的内存数，free表示还未进入内核控制的内存数，used还包括了停止使用但可能被重用的内存，所以used使用完的内存不会返还给free，所以free的内存数一定越来越少</strong>)</p>
</blockquote>
<p>  *第五行</p>
<blockquote>
<p>Swap total — 交换区总量<br><br>used — 使用的交换区总量<br><br>free — 空闲交换区总量<br><br>cached — 缓冲的交换区总量<br><br>(<strong>swap used经常变化的话说明内存已经不够使用了</strong>)<br><a href="http://www.cnblogs.com/kerrycode/p/5246383.html" target="_blank" rel="noopener">参考链接</a><br>(<strong>系统可使用的内存近似为第四行的free+buff/cache+第五行的cache</strong>)</p>
</blockquote>
<p>  *进程状态监控各项指标</p>
<blockquote>
<p>PID — 进程id<br><br>USER — 进程所有者<br><br>PR — 进程优先级<br><br>NI — nice值。负值表示高优先级，正值表示低优先级<br><br>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES<br><br>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA<br><br>SHR — 共享内存大小，单位kb<br><br>S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程<br><br>%CPU — 上次更新到现在的CPU时间占用百分比<br><br>%MEM — 进程使用的物理内存百分比<br><br>TIME+ — 进程使用的CPU时间总计，单位1/100秒<br><br>COMMAND — 进程名称（命令名/命令行）<br></p>
</blockquote>
<h3 id="top交互"><a href="#top交互" class="headerlink" title="top交互"></a>top交互</h3><p>执行top命令之后即进入top信心展示界面，可以使用命令行进行交互<br></p>
<ul>
<li>top界面 按1显示多核cpu的使用情况</li>
<li>top界面默认按cpu的使用降序排序<br>  使用shift+&gt;和shift+&lt;来改变排序的指标</li>
<li>top界面 按x高亮排序的指标</li>
<li>top其他使用技巧<br> h 显示帮助画面，给出一些简短的命令总结说明<br><br>  k 终止一个进程 <br><br>  i 忽略闲置和僵死进程。这是一个开关式命令 <br><br>  q 退出程序 <br><br>  r 重新安排一个进程的优先级别 <br><br>  S 切换到累计模式 <br><br>  s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m      s。输入0值则系统将不断刷新，默认值是5 s <br><br>  f或者F 从当前显示中添加或者删除项目 <br><br>  o或者O 改变显示项目的顺序 <br><br>  l 切换显示平均负载和启动时间信息 <br><br>  m 切换显示内存信息 <br><br>  t 切换显示进程和CPU状态信息 <br><br>  c 切换显示命令名称和完整命令行 <br><br>  M 根据驻留内存大小进行排序 <br><br>  P 根据CPU使用百分比大小进行排序 <br><br>  T 根据时间/累计时间进行排序 <br><br>  W 将当前设置写入~/.toprc文件中 <br></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 微服务问题定位 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux命令 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 进程,线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2018/01/24/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> 迎新 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> welcome </tag>
            
            <tag> hello </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
