<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[生产问题排查指南——排查思路]]></title>
    <url>%2F2018%2F02%2F12%2F%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"></content>
      <categories>
        <category>生产环境</category>
      </categories>
      <tags>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产问题排查指南——问题排查方法]]></title>
    <url>%2F2018%2F02%2F12%2F%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>生产环境</category>
      </categories>
      <tags>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产问题排查指南——指标查询指令与方法]]></title>
    <url>%2F2018%2F02%2F12%2F%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%8C%87%E6%A0%87%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>生产环境</category>
      </categories>
      <tags>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在mac上搭建python环境并使用docx模块]]></title>
    <url>%2F2018%2F02%2F12%2F%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83%E5%B9%B6%E4%BD%BF%E7%94%A8docx%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[背景之前接手到一个处理word文档的项目，需要读取word内容，并对读取的字符串进行一系列的处理。一开始笔者使用java进行处理，需要引入第三方模块——poi。说实话，这个第三方模块对于word的处理不够完善，第一没有很好的写入方式，第二没有很好的样式处理机制，第三没有封装java的io流，仍然需要笔者手动创建和关闭io资源。 在之后的资料中查询到可以使用python的docx模块很快速处理word文件，使用快捷方便，几行代码就可以实现读写，并且很好的支持word的样式。但是docx模块只支持docx后缀的文档，读者可以先将doc转换docx。 搭建环境搭建平台是macOS10.12.6，一般mac上是自带python的，但是普遍版本较低，目录位置为/Library/Python，以后安装的其他版本也在相同的目录下。 终端$python –version 查看python的版本。 这边可以使用pyenv来管理python的各个版本，笔者这边使用IDE(python编译环境)管理的。如果选择pyenv，请参考。即使不使用pyenv，笔者还是要推荐参考博客中提及的brew——mac的统一依赖包管理器。如果选择IDE管理，请到官网下载PyCharm，这种方式不像pyenv可以使用命令下载python的其他版本，读者可以访问官网下载其他python版本。 IDE在栏目PyCharm下选择Pereferences，如图选择可以切换编译器的python版本：不同的版本切换对代码的编译可能会造成影响。 引入docx模块python处理word也需要引入第三方模块，一般使用pip去下载python的第三方模块。mac里面python自带easy_install。$sudo easy_install pip 输入密码下载pip，笔者强烈建议不要在系统自带的python下折腾，因为mac系统下很多软件都依赖python模块，一些操作可能导致系统的软件打开错误。 读者可以先去官网下载其他版本，然后设置环境变量，sudo vim /etc/profile，编辑添加export PATH=xxxx:$PATH，其中xxxx为下载后python的路径，参考搭建环境。 $python –version 查看版本是否更改，之后执行$sudo easy_install pip，然后在执行$pip install docx模块。 然后读者就可以在当前python版本的目录下看到pip模块和docx模块了。之后在PyCharm中切换python的版本，在编写的代码中引入docx模块即可。读者可以参考官网手册]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm——新生代,老年代和持久代]]></title>
    <url>%2F2018%2F02%2F11%2Fjvm%E2%80%94%E2%80%94%E6%96%B0%E7%94%9F%E4%BB%A3-%E8%80%81%E5%B9%B4%E4%BB%A3%E5%92%8C%E6%8C%81%E4%B9%85%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[新生代，老年代和永久代java中堆是jvm所管理的最大的一块内存空间，主要用于存放各种类的实例对象。jvm中内存的分配有如下公式： 堆 = 年轻代 + 老年代 年轻代 = eden space(新生代) + from survivor + to survivor 年轻代默认值保持为堆大小的1/15，特点是对象更新速度快，在短时间内产生大量的死亡对象，并且要产生连续可用的空间。所以使用复制清楚算法和并行收集器进行垃圾回收，对年轻代的垃圾回收称作初级回收(minor gc)。 年轻代的工作机制jvm，年轻代中每次只会使用eden space和其中一块survivor区域来为程序服务，所以无论如何总有一块survivor区域总是空闲的。对象在 eden 中初始化，在经过一次minor gc后，如果对象还存活着，即被引用着，并且能够被另外一块survivor区域所容纳，则使用复制算法将这些仍然还存活的对象复制到另外一块survivor区域中。 年轻代如何变成老年代初始化过程与上面一致，在eden中。在minor gc之后，如果对象还存活着，这些对象的年龄+1，当超过某个值(默认为15)这些对象进入老年代。 老年代的gc堆内存的老年代不同于现实生活，老年代中的对象个个都是从survivor中熬过来的，所以老年代中的类不是那么容易死亡的。因此，full gc(又称major gc)发生的次数没有minor gc那么频繁，并且一次full gc要比minor gc时间要更长。标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。 持久代此外还有一个持久代，用于存放静态文件，如java类定义(相当于模版，不是实例对象)、方法、本地方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate等，在这种时候需要设置较大的持久代空间来存放这些运行过程中新增的类 。持久代大小通过-XX:MaxPermSize=进行设置。 补充有的虚拟机并没有持久代，java8开始持久层也已经被彻底删除了，取代它的是另一个内存区域也被称为元空间。想要参考更多，读者可以参考这篇博客 jvm配置项jvm配置项可以根据程序的实际要求来配置，如各个代的比例等。这边原本应该用表格的形式展示，但是hexo在渲染markdown的表格语法时不支持，待到作者修复这个bug后进行更改。1234567891011121314151617181920212223242526* -Xms 初始堆大小。如：-Xms256m* -Xmx 最大堆大小。如：-Xmx512m * -Xmn 新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90% * -Xss JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的 话， 1M 是绝对够用了的。 * -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2， 则新生代占整个堆空间的1/3，老年代占2/3 * -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。 即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10 * -XX:PermSize 永久代(方法区)的初始大小 * -XX:MaxPermSize 永久代(方法区)的最大值 * -XX:+PrintGCDetails 打印 GC 信息 * -XX:+HeapDumpOnOutOfMemoryError 让虚拟机在发生内存溢出时 Dump 出当前的内 存堆转储快照，以便分析用]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五行相生——第二章]]></title>
    <url>%2F2018%2F02%2F04%2F%E4%BA%94%E8%A1%8C%E7%9B%B8%E7%94%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[太阳已经落山了，迷迷重雾之后，一处红火若隐若现。 “哟，您来啦，来人准备上房。” “怎么，你在这里身份好像很尊贵？” 粘土想探探铄金的身世。”楼上准备了热水，你可以洗漱一番。” 铄金避而不答，引着粘土到了这里的最高层。 没有想象的靡靡之音，有的而是琴箫入耳，一曲琵琶。”这里到是一片高雅，并不是你说的那种地方？” “这里的姑娘都是卖艺不卖身，而且各个身怀武艺，是江湖中用来交换情报的地方。” “哦，你倒是挺熟的？” “因为现在站在你面前的是这儿的头。” 只见铄金狡黠一笑。 “先沐浴更衣吧。明日一早再出发不迟。” 然而粘土迟迟未动，”你…你先回避一下。” 软儒的声音再次传来，粘土此刻羞红了脸，背对身去。”我俩都是女子，为何还如此害羞？” “谁说女子就…就不会？我就知道世上还有女子可以相爱。” 铄金并没有回应，粘土此时转过身来，只见一头金发披散开来，在烛光下熠熠生辉，显的背后更加白皙光泽。”你…你怎先脱去了衣物？” “这一路赶来，我也好几天没有洗漱了，正好今天洗个痛快。” “你先进去吧！” 只见粘土仍背对着，不敢回头。铄金慢慢移步过来，”今晚只备了一份水，只能一起喽。” 说罢便脱去了粘土的衣服，”你，快快转过身去！” 粘土双臂抱在胸前喝斥道。”好好好，我转过去，你且自行脱去，我先进去了。”]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>武侠</tag>
        <tag>传记</tag>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五行相生——第一章]]></title>
    <url>%2F2018%2F02%2F04%2F%E4%BA%94%E8%A1%8C%E7%9B%B8%E7%94%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[“喂喂喂，听说没有，江南城里发生了命案，死的是当地的地头蛇，听说是一剑封喉，连凶手的身影都没有看到。” 此时茶坊里人们正在议论纷纷，三日前在江南城中发生的大案到了这里也不过众人的茶余饭后。 茶坊中间的桌子上，一位客人正喝着茶，此人一头金色短发，腰间挂着一把鱼肠短剑，静静听着旁人的纷纷议论。 “这位姑娘，可否容在下在此就座？” 一句温柔的声音打破了女子的静静偷听，抬头望去，面前站着身着长衫的女子，长发垂条，手持一把褐色长杖，惊堂木挂于腰间。”为何就座我这里？” 金发女子保持了应有的警觉性，尖锐的眼神中似乎发问道。”在下看姑娘一身正气，似乎旁边也没有合适之地。” 长发女子眉间弱气了几分，话语也软儒了几分。”唉，坐吧。” 两人都静静喝着茶，一时间气氛陷入诡异。 “在下粘土，请问姑娘芳名？” 粘土长舒一口气，心想终于打破了这尴尬的局面。”在下铄金，正北上办一件事，才会路经此地，我看姑娘文文弱弱，为何来此荒野之地？” “在下受一位故友之托去北方边城之地送信，方圆没有人家，炎炎夏日，来此歇脚。” 铄金看着面前的女孩，脸上尽是风霜，绳鞋上的双脚也都尽是污垢，就知一路受尽苦楚，但也掩不住女子坚毅的气息与姣好的面容，就知再过不久女子便要远行，心生怜悯之情。但是内心挣扎，迟迟没有开口。 “姑娘请留步。” 铄金还是留住了粘土，”今晚可已有住处？” “此去早已知晓，以天为被，以地为床。” 粘土回头莞尔一笑。铄金对眼前的女子更生钦佩之情，”再往北10里，有家客栈，处于迷雾之中，少有人见，在下正要到那投宿，不知姑娘有意同行？” “当真！” 粘土心中甚是兴喜，没有沐浴半月有余，正好要去去尘垢。 “你我现在同行，不必如此生分，你叫我铄金便可。” “那铄金唤我粘土吧，看我长你几岁，叫姐姐也尚可。” 粘土的嬉笑着调戏到。”哦，粘土为何如此信任我，你可知今晚我们投诉的地方是哪儿？” 看着一脸疑惑的粘土，铄金突然凑近贴着耳朵缓缓说道：”乃风花雪夜之所，粘土就不怕我把你卖了？” 看着粘土的防备，长杖紧贴身前，铄金哈哈大笑向前走去。粘土紧跟其后，知道被骗了，心有不甘。”我看你天性纯真，但防人之心不可无，以后不要因人其表就被他人骗了去。” 铄金停下严肃道，粘土的眼中倒映出一抹深深，弱弱道：”但是我知道你不是坏人！” “哦，你难道懂窥心之术？” 粘土并未回答，只是跟了上去。 两人并排向前，身后是拉长的斜影。]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>武侠</tag>
        <tag>传记</tag>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux编辑器——vim]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E7%BC%96%E8%BE%91%E5%99%A8%E2%80%94%E2%80%94vim%2F</url>
    <content type="text"><![CDATA[VIM编辑器背景vi在mac下严格意义上讲不是一个简单的命令，而是unix系列下的自带的编译器，笔者没记错发明这编译器的家伙是个大胡子，一直致力于软件开源的维护和倡导$vi filename 这是开始编译一个文件，有时候需要switch user 即sudo 简介这边笔者不做过多的介绍请看维基百科这里的vim编辑器是vi的一种升级版 编辑文件之前说过基本用法:$vim filename，这边还有其他的用法$vim +line filename 编辑文件，并定位到第line行$vim + filename 编辑文件，并定位到最后一行$vim +/pattern filename 编辑文件，并定位到第一个匹配的位置 关闭文件这边需要提及vim的模式(之后补充，这边提及)，打开文件后需要进入输入模式或者其他模式，才能使用一些命令，退出模式后才能关闭文件一般按esc按钮来推出vim的模式，然后输入:来选择退出的方式:q 退出:wq 保存并退出:q! 不保存并退出:w 保存但没有退出，可以继续编辑:w! 强行保存退出后就回到命令窗口界面了，当然也可以直接编辑模式退出如：编辑模式按ZZ即可 模式i 在当前光标所在的字符前面转为输入模式a 在当前光标所在的字符后面转为输入模式o 在当前光标所在行的下方新建一行，并转为输入模式I 在当前光标所在行的行首转为输入模式A 在当前光标所在的行尾转为输入模式O 在当前光标所在的上方新建一行，并转为输入模式以上的命令必须是非编辑状态或者非其他的状态，然后按下相应的按键进入编辑模式 相关命令移动很简单，就是键盘上的上下左右键w 移至下一个单词词首，中文一般以标点为准跳动e 移至当前或下一个单词词尾b 移至当前或者前一个单词词首nw 移动n个单词 跳转0 跳转到光标所在的行首^ 跳转到行首的第一个非空白字符$ 绝对的行尾nG 跳转到第#行gg 跳转到第一行行首G 跳转到最后一行行首 翻页ctrl+f 向下翻一屏ctrl+b 向上翻一屏ctrl+d 向下翻半屏ctrl+u 向上翻半屏 删除x 删除光标所在处的单个字符nx 删除光标所在处及后面共n个单词dd 删除光标所在的行ndd 删除光标所在行及后面共n行 粘贴p: 如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面P: 如果删除或复制为整行内容，则粘贴至光标所在行的上方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的前面以上命令只作用于vim编辑器内部，外面复制的内容不行 复制用法和d命令的用法相同，将d替换成y 替换r 替换单个字符，但是好像不支持中文nr 光标后n个字符全部替换R 进入替换模式，可直接替换光标所在的字符 撤销编辑操作u 在非模式状态下，撤销前一次的编辑操作nu 直接撤销最近的n次编辑操作 选取v 进入选取模式，按字符选取，最多到光标所在的行V 进入选取模式，但是按矩形进行选取 查找:/pattern 根据匹配的字符查找:?pattern 同上n 下一个N 上一个 查找并替换headline,footline s#PATTERN#string#gn,$s#wyc#王鋆昌#g 替换第n行开始到最后一行中每一行所有wyc为王鋆昌参考 编辑多个文件vim file1 file2:next 切换到下一个文件:prev 切换到上一个文件:last 切换到最后一个文件:first 切换到第一个文件:q 退出当前文件:qa 全部退出 未完待续vim的使用远非及此，之后还有有涉及会及时补充]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令——crontab]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94crontab%2F</url>
    <content type="text"><![CDATA[crontab作用自定义定时任务笔者一般用这个命令来提醒事项，适用于基本每天执行的事项 option参数-e 编辑cron脚本文件，可以指定编辑器，默认是vi编辑器-l 列出当前用户下的cron任务-u 指定cron在哪个用户下执行，默认是当前用户 使用实例$brontab -e 执行后跳到编辑器你可以在编辑器中书写cron命令，一般的格式是 command content上面格式中的 从左至右分别表示分，时，日，月份和年份，content就是自定义的命令了如果命令较多，你甚至可以写在一个shell脚本中，执行脚本即可比如：15 9 * command sh xxx.sh 每天早上9:15执行xxx.sh脚本 扩展一般用$cron -e编辑的脚本，笔者也不知道保存到哪里去了，一般笔者都是写完之后直接执行的比如：crontab test.cron即可，test.cron即为编写好的脚本，内容形式与上面的一致 实用价值了解敏捷开发的读者应该知道，部门中可能存在一些管理方式，需要每天执行任务，比如早晨的定时晨会，比如记录一天内的工作时间，等等读者可以使用outlook来提醒，或者手机的定时闹钟，笔者选择用crontab命令来显示高逼格列出了笔者mac中每天执行的任务，将多个cron任务编辑在同一个.cron文件内，执行就能实现多个任务的并存发现cron任务content可以直接命令，也可以shell脚本执行]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令——awk]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94awk%2F</url>
    <content type="text"><![CDATA[awk用法awk ‘{pattern + action}’ {filenames} 使用方式awk -F 分隔符 ‘{command操作}’awk -f awk-script-file input-file(s)上面的命令比较有意思，awk-script-file是脚本文件，一般比较复杂的awk命令可以写成一个脚本，然后操作到input-file(s)文件上 内置变量ARGC 命令行参数个数ARGV 命令行参数排列ENVIRON 支持队列中系统环境变量的使用FILENAME awk浏览的文件名FNR 浏览文件的记录数FS 设置输入域分隔符，等价于命令行 -F选项NF 浏览记录的域的个数NR 已读的记录数OFS 输出域分隔符ORS 输出记录分隔符RS 控制记录分隔符 使用实例在xqy的日志使用手册中，有统计所有抛出非业务异常的服务的命令，相信很多开发不知道运行的原理，在此我做一下说明：cat common-service-digest.log | grep ‘N,’ | awk -F ( ‘{print $2}’ | awk -F ) ‘{print $1}’ | awk -F , ‘{!a[$1”.”$2”.”$3]++;}END {for (j in a) print j,a[j]}’这个命令比较长，你可以分开进行执行，比如:1.cat common-service-digest.log | grep ‘N,’ 查看调用失败的日志2.awk -F ( ‘{print $2}’ 以 （作为分隔符分割日志行，并打印分隔片区2比如:日志记录:[(tax,ICustomerSettingManageService,getAreaCodeBatch,Y,12ms)] (traceId=84ec429fbff64c5bbc43347c8cc72257)被分隔为:[(tax,ICustomerSettingManageService,getAreaCodeBatch,Y,12ms)](traceId=84ec429fbff64c5bbc43347c8cc72257)最后输出:tax,ICustomerSettingManageService,getAreaCodeBatch,Y,24ms)]3.awk -F ) ‘{print $1}’ 以 ）作为分隔符分割日志行，并打印分隔片区1最后输出:tax,ICustomerSettingManageService,getAreaCodeBatch,Y,12ms4.awk -F , ‘{!a[$1”.”$2”.”$3]++;} 以 ,作为分隔符分割日志行，并以$1”.”$2”.”$3为键统计5.最后end进行循环输出参考 说明当中涉及到xqy的日志业务和图片，所以不部署到github]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令——sed]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94sed%2F</url>
    <content type="text"><![CDATA[sed系统mac系统用的是原生的bsd系列，而一般的linux系统用的是gnu系统，所以两者在某些命令是有区别的，sed命令位列其中 区别mac上sed的添加和插入文本比较奇葩，需要如此:$sed “$line a\ (在\后要加一个空格，然后另起一行，再写需要添加的那一行新的)>$value（需要添加新一行的内容）>“ $filename(文件名)同上，sed i的使用方式亦然 gnu-sed如果无法适应原生bsd系列，可以下载gnu-sed，这个时候brew神器又用到了，直接下载然后配置环境变量即可:$brew install gnu-sed之后的叙述都是基于gnu-sed说明 option参数-n ：使用安静(silent)模式，在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上，但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来-e ：直接在命令列模式上进行 sed 的动作编辑-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)-i ：直接修改读取的文件内容，而不是输出到终端 方法a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法 实例$sed ‘2a 字符串’ filename —— 第二行下一行添加字符串$sed ‘2i 字符串’ filename —— 第二行上一行添加字符串以上的命令只能作用在缓存的文件中，其实真实的文件内容并没有被改变$sed ‘2a 字符串’ -i filename —— 这样可以直接修改文件了$sed ‘1,2d’ -i filename —— 删除文件1-2行的内容sed与nl联合使用可以进行关键字查找:$nl filename | sed -n ‘/关键字/p’sed支持正则表达的搜索和替换:$sed ‘s/正则表达式 or 普通字符串/新字符串/g’ -i filename[其他用法:]https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2856901.html]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令——补充]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[常用命令(补充)grep用法grep [-acinv][–color=auto] ‘查找字符串’ filename option参数-c 统计查找字符在文件中出现的次数-i 忽略大小写-v 反向查找，即显示不在查找内的行，但是根据记录日志的习惯，很少会使用–color=auto 对查找的字符进行颜色显示 联合使用ls -l |grep -i filename 列出指定文件/文件夹的属性ps -ef|grep tomcat/java 列出指定的进程信息 find用法find [PATH] [option] [action] option参数-mtime n 其中n为数字，表示n天以前，查找n天之前修改过的文件-user name 查找指定所有者的文件-size [+-size] 查重比size大/小的文件 使用$find . -mtime 0 来查找当天修改过的文件，一般可以筛选当天有记录的日志 taroption参数-c ：新建打包文件-t ：查看打包文件的内容含有哪些文件名-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中-j ：通过bzip2的支持进行压缩/解压缩-z ：通过gzip的支持进行压缩/解压缩-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来-f filename ：filename为要处理的文件-C dir ：指定压缩/解压缩的目录dir 使用实例$tar -tzvf xxx.zip 查看指定压缩文件里面的文件内容$tar -zxvf xxx.zip 解压缩指定文件$tar -cvf xxx.tar dir 压缩指定文件夹$tar -czvf xxx.tar.gz dir 以gzip的格式进行压缩如何使用解压缩命令的option操作，最终还是要看压缩文件的格式的，如-z一般用来支持.gz结尾的压缩包 kill用法kill [选项] [参数] option参数-a：当处理当前进程时，不限制命令名和进程号的对应关系-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称 -p：指定kill 命令只打印相关进程的进程号，而不发送任何信号-s &lt;信息名称或编号&gt;：指定要送出的信息-u：指定用户 常用的信号编号HUP 1 终端断线 INT 2 中断（同 Ctrl + C） QUIT 3 退出（同 Ctrl + \） TERM 15 终止 KILL 9 强制终止 CONT 18 继续（与STOP相反， fg/bg命令） STOP 19 暂停（同 Ctrl + Z）在mac中18是STOP，19是CONT]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令文件上传与下载]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%91%BD%E4%BB%A4%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[文件上传下载搭建实践环境这边使用笔者自己的电脑和windows电脑进行实践。 利用ssh打通windows和mac打开mac的系统偏好设置中的共享，一般情况下没有界面展示的，需要使用搜索查找共享， 然后勾选远程登陆，选择全部用户可访问 在windows上使用ssh连接mac，填写相应的用户名和密码即可 安装要支持sz，rz两个命令，系统需要安装lrzsz，一般的linux系统是自带的，这里使用mac进行实验，需要安装。参考 使用sz filename，即从系统上下载文件到本地，filename是系统中你选择下载的文件rz -b，将本地的文件以二进制的传递方式上传到系统服务器，一般推荐使用二进制传输方式其他参考]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo防止敏感数据部署]]></title>
    <url>%2F2018%2F01%2F30%2Fhexo%E9%98%B2%E6%AD%A2%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[hexo防止敏感数据部署原理熟悉hexo的读者都知道，hexo的部署一般执行如下:$hexo clean$hexo g$hexo d如果不按照顺序执行这三步，读者会发现即使增添了page，部署时git也不会显示增添文件的记录，github上也没有提交的代码记录其实这涉及到hexo的部署原理，hexo clean 会清除之前构建的代码，具体就是public文件夹；hexo g 会重新生成，这样读者添加的page也就构建在其中，此时新的public文件夹会生成；hexo d 就是将hexo g 改变的文件提交到github上所以不执行clean和generate是不会真正意义上修改remote上的代码 敏感数据敏感数据这里指的就是涉及公司业务的文章，因为hexo d 会将文章直接部署到github上，这样就全部公开化了这边最好是本地可以访问，github无法访问你的敏感数据，这篇文章的目的就在此 利用.gitignore熟悉git的读者，应该都知道可以使用.gitignore文件忽略一些提交网上有些说修改.npmignore文件配置(hexo的根目录下)可以起到效果，经过测试发现没有起到作用，所以转而到git寻求解决方案一般执行如下(当前目录为hexo根目录):$cd .deploy_git git push的代码都在此文件夹下$vim .gitignore增加如下配置:page name/ page的名称，hexo n page创建命令中你定义的文章名，如:linux命令性能监控及优化/.gitignore 自己本身但是笔者发现代码虽然没有提交到github上，但是hexo博客上有这个新建的标题，点击访问也是github默认的404页面(因为hexo g过程中一定会将文章标题写入hexo中，.gitignore只能做到忽略提交) 自定义404上面的问题引入了这个小结，github默认的404页面会让读者误以为是网站的问题，其实是不想公开化，所以你可以自定义404页面具体的步骤如下(hexo的根目录下):$hexo n page 404 source目录下生成404目录index.md中增加配置: layout: false //是否使用布局文件 comments: false //是否有评论 permalink: /404 //设置链接然后按照hexo部署步骤上传到github上，然后再访问敏感文章链接会跳转到自定义的404页面其实根本问题是github上没有代码，但是hexo在generate时将目录还是写入了导致，但是笔者找不到解决忽略写入的方法]]></content>
      <categories>
        <category>hexo部署</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令性能监控及优化]]></title>
    <url>%2F2018%2F01%2F30%2Flinux%E5%91%BD%E4%BB%A4%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[性能监控和优化toptop freefree vmstat用来统计虚拟内存的使用情况，这边涉及到linux物理内存和虚拟内存的知识点，其实之前我们也提到过，虚拟内存即交换区 option参数-a：显示活跃和非活跃内存-f：显示从系统启动至今的fork数量-m：显示slabinfo-n：只在开始时显示一次各字段名称-s：显示内存相关统计信息及多种系统活动数量delay：刷新时间间隔。如果不指定，只显示一条结果count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷-d：显示磁盘相关统计信息-p：显示指定磁盘分区统计信息-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）默认单位为K（1024 bytes）-V：显示vmstat版本信息 使用实例$vmstat 5 6 在docker上进行试验，在6秒内采集5次数据 说明Procs（进程）：r: 运行队列中进程数量b: 等待IO的进程数量Memory（内存）：swpd: 使用虚拟内存大小free: 可用内存大小buff: 用作缓冲的内存大小cache: 用作缓存的内存大小Swap：si: 每秒从交换区写到内存的大小so: 每秒写入交换区的内存大小IO：（现在的Linux版本块的大小为1024bytes）bi: 每秒读取的块数bo: 每秒写入的块数系统：in: 每秒中断数，包括时钟中断cs: 每秒上下文切换数CPU（以百分比表示）：us: 用户进程执行时间(user time)sy: 系统进程执行时间(system time)id: 空闲时间(包括IO等待时间),中央处理器的空闲时间 以百分比表示wa: 等待IO时间 需要关注的指标如果 r经常大于 4 ，且id经常少于40，表示cpu的负荷很重如果bi，bo 长期不等于0，表示内存不足如果disk 经常不等于0， 且在 b中的队列 大于3， 表示 io性能不好]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2018%2F01%2F30%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用命令pwd没什么可说的，当前不知道处于那个目录下时，pwd即可 mvmv命令是将一个文件移动到指定的目录，但是在linux可以用来重命名文件 moremore是具有翻页功能的cat命令 lessless是一个可以前后分页浏览文件的命令，相比more更加具有弹性 whichwhich用于查找命令包所在的路径，没有配置在环境变量中的命令是搜索不到的，因为which只会搜索path下的命令，echo $PATH可以查看 lsls命令还是很常用的，不做过多描述ls g* 模糊列出文件列表，即将g开头的文件列出 unzip和gzipunzip主要用于解压.zip压缩文件 unzip xxx.zipgzip file1 file2 … 文件打包压缩为.gz的形式对于文件夹的打包或者其他的压缩格式请使用tar命令 whatis和man$whatis command 用于显示命令使用的描述$man command 以使用手册的形式显示]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——jmap]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94jmap%2F</url>
    <content type="text"><![CDATA[jmap使用场景 内存溢出，线上程序运行时内存越来越大，用jmap dump出堆内存的信息，然后进行相关分析 内存的真实使用大于预期，这是因为设计不合理导致冗余的对象存在内存中，用jmap来查看内存中的对象，分析是否有存在的必要 jvm优化，利用jmap来查看整个堆的使用情况，根据老年代和新生代的使用比例来划分jvm的各个区域 使用实例在使用jmap连接进程时，启动的jvm版本和jdk版本要一一对应，毕竟jmap是jdk下的命令包$ps -ef | grep java 查找系统的java进程$jmap -heap pid 打印指定进程堆的摘要信息，包括gc算法 参数说明 Heap Configuration: 堆配置信息 MinHeapFreeRatio 在堆的使用率小于MinHeapFreeRatio(%)的时候进行收缩，当Xmx=Xms的时候此配置无效MaxHeapFreeRatio 在堆使用率大于MaxHeapFreeRatio(%)的时候进行扩展，当Xmx=Xms的时候此配置无效MaxHeapSize 堆的最大空间NewSize 新生代的大小MaxNewSize 最大的新生代的大小OldSize 老年代的大小NewRatio 老年代和新生代的比例SurvivorRatio 新生代中Eden和和Survivor区的比例PermSize 永久代的大小MaxPermSize 久代的最大内存G1HeapRegionSize 使用G1垃圾收集的区间 Heap Usage: 堆的使用信息 New Generation (Eden + 1 Survivor Space): 新生代的大小（Eden区加一个Survivor区的空间信息 capacity 总内存used 已使用内存free 剩余内存13.823827124993642% used 使用内存占比 Eden Space: Eden区的大小 capacityusedfree15.178337946947952% used From Space: 第一个Surivivor区的空间信息 capacityusedfree2.984432830624237% used To Space: 第二个Survivor区的空间信息 capacityusedfree0.0% used concurrent mark-sweep generation: CMS垃圾收集占用的空间信息 capacityusedfree75.36470666527748% used Perm Generation: 永久代的空间信息 capacityusedfree47.5915253162384% used 其他功能参考链接]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——jstack]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94jstack%2F</url>
    <content type="text"><![CDATA[jstack功能查看运用程序jvm的堆栈情况，可以找出线程的运行情况，从而排查一些隐患或者服务卡顿的问题 具体说明jstack用于打印出给定的java进程id或者core file或者远程调试服务的java堆栈信息，如果是在64位机器上，需要指定选项-J-d64如果java程序崩溃会生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松知道java程序是如何崩溃和在程序何处发生问题。 option参数-F 当jstack -l pid 没有响应的时候强制打印栈信息-l 长队列，打印关于锁的附加信息-m 打印java和native c/c++框架的所有栈信息 命令格式jstack [option] pidjstack [option] executable corejstack [option] [server-id@]remote-hostname-or-IP 命令格式说明executable core 产生core dump的java可执行文件remote-hostname-or-IP 远程debug服务的主机名或ipserver-id 唯一id,假如一台主机上多个远程debug服务 使用实例一般需要与top命令联用，使用top命令找出异常的进程(一般是cpu使用异常的进程)通过top -Hp pid来定位该进程下各线程的cpu使用情况再通过jstack pid命令打印该线程对应的堆栈情况 扩展 在top命令中，已经获取到了占用cpu资源较高的线程pid，将该pid转成16进制的值(在线转换)，在thread dump中每个线程都有一个nid，找到对应的nid即可 什么是java core和heap dump文件，参考]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitbook目录折叠]]></title>
    <url>%2F2018%2F01%2F28%2Fgitbook%E7%9B%AE%E5%BD%95%E6%8A%98%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[gitbook目录折叠背景在编写gitbook的时候发现目录的数量比较庞大的时候显得杂乱无章因为章节比较多的时候全展开，很难有目的地寻找所以笔者去寻求了解决之道，用来折叠目录，笔者在网上找到了一个插件可以解决这个问题 插件插件网站上面还有其他gitbook使用的插件 使用参考个性化配置gitbook，同理你可以在里面添加需要使用的插件，如图book.json在根目录下，即与SUMMARY.md同级$ cd到gitbook目录$ npm install gitbook-plugin-toggle-chapters重新build serve即可]]></content>
      <categories>
        <category>gitbook</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在本地搭建gitbook]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAgitbook%2F</url>
    <content type="text"><![CDATA[本地搭建gitbook介绍gitbook更加适用于书写使用手册，不太适合书写一些博客和总结，所以笔者最近在做一些迁移的工作，将之前gitbook上的内容迁移到当前的博客上但是gitbook对于我们的工作还是有适用的地方的 先决条件安装nodejs是先决条件，因为我们需要npm去下载gitbook在mac电脑上，有brew工具的可以直接下载:$brew search nodejs 搜索包仓库中是否有nodejs$brew install nodejs 有就可以直接下载你也可以选择去官网上下载最新的nodejs压缩包，解压配置环境变量后即可使用 搭建这里默认大家的电脑上已经安装好了nodejs按照步骤执行以下命令:$npm install gitbook-cli -g 下载gitbook客户端包$gitbook –version 查看gitbook的版本，测试是否可以使用命令$cd /users/Desktop 切换到一个目录，这里笔者切换到了桌面$mkdir gitbook 创建gitbook目录，这个目录就是用来初始化的其实上面的两步读者可以手动完成$gitbook init 初始化gitbook$gitbook build 构建，一般有内容更新时要构建$gitbook serve 开启服务，默认在4000端口监听http://localhost:4000 开启你的访问之路吧！ 问题笔者之前在windows上搭建过，出现了一些问题，build的时候总是报错在github官方issues中，官方表示这个是已知的gitbook的bug，高版本的gitbook会出现这个bug如果你遇到相同的问题，请参考:解决方法解决方法是点赞和喝彩最多的]]></content>
      <categories>
        <category>gitbook</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——du]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94du%2F</url>
    <content type="text"><![CDATA[du功能du命令也是查看使用空间的，但是与df命令不同的是 du命令是对文件和目录磁盘使用的空间的查看 option参数-a或-all 显示目录中个别文件的大小-b或-bytes 显示目录或文件大小时，以byte为单位-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和-k或–kilobytes 以KB(1024bytes)为单位输出-m或–megabytes 以MB为单位输出-s或–summarize 仅显示总计，只列出最后加总的值-h或–human-readable 以K，M，G为单位，提高信息的可读性-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过-L&lt;符号链接&gt;或–dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件–exclude=&lt;目录或文件&gt; 略过指定的目录或文件-D或–dereference-args 显示指定符号链接的源文件大小-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位-l或–count-links 重复计算硬件链接的文件 实例$du 显示当前目录下面子目录的目录大小和总和$du dir/filename 显示指定目录或者文件$du #1 #2 同时显示多个，空格隔开]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——df]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94df%2F</url>
    <content type="text"><![CDATA[df功能用来检查服务器文件系统的磁盘空间占用情况，可以获取硬盘被占了多少空间，目前还剩下多少空间等信息 option参数-a 全部文件系统列表-h 方便查阅方式显示-H 等-h，但是计数方式变更，1k=1000-i 显示node信息-k 区块为1024字节-l 只显示本地文件系统-m 区块为1048576字节–no-sync 忽略sync命令-P 输出格式为POSIX–sync 在取得磁盘信息前先执行sync命令-T 文件系统类型 选择参数–block-size=&lt;区块大小&gt; 指定区块的大小-t &lt;文件系统类型&gt; 只显示选定文件系统的磁盘信息-x &lt;文件系统类型&gt; 不显示选定文件系统的磁盘信息 使用实例第一列 显示各文件系统第二列 显示文件系统的块数 这里以512B为一块第三列 显示已经使用的磁盘第四列 显示可用的磁盘其他这边需要说明：已使用的+可使用的 != 总块数，因为缺省的每个分区都预留了少量空间供管理员使用，所以即使普通用户的空间已满，管理员依然可以登录系统解决相关问题]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——ifstat]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94ifstat%2F</url>
    <content type="text"><![CDATA[ifstat功能监控系统的流量问题 安装ifstat不是系统自带的命令，所以需要进行安装，笔者这里只介绍mac上如何安装$brew install ifstat当然这边brew要自行安装 参数-l 监测环路网络接口(lo)，缺省情况下不会显示，所谓的环路网络可认为是localhost(127.0.0.1)参考-a 监测系统所有的网络，比加上-l参数还多一个plip0的接口信息(所谓的并口)-z 隐藏流量是无的接口，排查问题时排除无用端口-i 指定要监测的接口,后面跟网络接口名-s 等于加-d snmp:[comm@][#]host[/nn]] 参数，通过SNMP查询一个远程主机-t 在每一行的开头加一个时间 戳,，告诉我们具体的时间-T 报告所有监测接口的全部带宽，和-i联用来指定端口-S 在同一行更新流量状态，不喜欢屏幕滚动的可以使用其他命令 扩展如何只查看网卡的流量情况，ifstat足矣详细的流量情况需使用iftop命令，系统依旧不会自带需要下载，mac下载方式与ifstat一致可以查看恶意请求流量的ip地址，并进行相关防护措施实例参考]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——free]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94free%2F</url>
    <content type="text"><![CDATA[free功能 显示系统使用和空闲的内存情况，包括物理内存和交互区内存(swap)和内核缓冲区内存 option参数 -b 以Byte为单位显示内存使用情况 -k 以KB为单位显示内存使用情况 -m 以MB为单位显示内存使用情况 -g 以GB为单位显示内存使用情况 -o 不显示缓冲区调节列 -s&lt;间隔秒数&gt; 持续观察内存使用状况 -t 显示内存总和列 -V 显示版本信息 样例 这边关注第二行的swap的used指标，如果使用的值较大，则表示系统的内存处于不够使用的情况 为何swap used是一个指标 swap又称为交换分区，当系统的内存小于额定值的时候，内核(OS)会将系统的一部分物理内存释放出来用于当前线程的使用，一般是很久没有操作过的程序会被释放，释放的物理内存被放入到交换区，然后等当前线程执行完毕，内存富余时重新放入物理内存]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>内存相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——strace]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94strace%2F</url>
    <content type="text"><![CDATA[strace以下说明都是基于docker系统机器实验 功能 系统调用和信号传递的跟踪 option参数 -c 统计每一系统调用的所执行的时间,次数和出错的次数等 -d 输出strace关于标准错误的调试信息 -f 跟踪由fork调用所产生的子进程 -tt 在输出中的每一行前加上时间信息,微秒级， 时间格式：17:22:58.345879 -p pid 跟踪指定的进程pid 以上命令一般都是与-p联用 strace的命令使用比较复杂，不做详细说明 在此贴出网上的一些参考链接 strace实例 strace实例2 样例贴图 从缺]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>进程,线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——top]]></title>
    <url>%2F2018%2F01%2F26%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94top%2F</url>
    <content type="text"><![CDATA[功能显示当前系统正在执行的进程的相关信息，包括进程ID、 内存占用率 、CPU占用率等 option 使用参数-b 进入批处理模式 相当于不停地执行top命令显示信息-c 显示完整的command 位于信息的最后一列-i &lt;时间&gt; 设置间隔时间 -u &lt;用户名&gt; 显示指定用户的信息 -p &lt;进程号&gt; 显示指定进程的信息 -n &lt;次数&gt; 循环显示的次数 … 例图 说明 *第一行: 13:40:29 — 当前系统时间10 day,2:32 — 机器从开机到目前为止运行的时长20 users — 登陆的用户有20个load average — 分别对应1mins,5mins,15mins的负载情况(根据一定的算法得到的值，load average／cpu数量&gt;=5说明系统超负荷) *第二行 Tasks total — 当前系统进程269个running — 正在运行的1个sleeping — 睡眠的268个stopped — 停止的0个zombie — 僵尸进程0个 *第三行 0.1%us — 用户空间占用CPU的百分比。0.0% sy — 内核空间占用CPU的百分比。0.0% ni — 改变过优先级的进程占用CPU的百分比99.9% id — 空闲CPU百分比0.0% wa — IO等待占用CPU的百分比0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比0.0% si — 软中断（Software Interrupts）占用CPU的百分比 *第四行 Mem total — 物理内存总量 8GBfree — 空闲的内存 used — 正在使用的内存buff/cache — 缓存的内存(used表示现在系统内核控制的内存数，free表示还未进入内核控制的内存数，used还包括了停止使用但可能被重用的内存，所以used使用完的内存不会返还给free，所以free的内存数一定越来越少) *第五行 Swap total — 交换区总量used — 使用的交换区总量free — 空闲交换区总量cached — 缓冲的交换区总量(swap used经常变化的话说明内存已经不够使用了)参考链接(系统可使用的内存近似为第四行的free+buff/cache+第五行的cache) *进程状态监控各项指标 PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值。负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RESRES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATASHR — 共享内存大小，单位kbS — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1/100秒COMMAND — 进程名称（命令名/命令行） top交互执行top命令之后即进入top信心展示界面，可以使用命令行进行交互 top界面 按1显示多核cpu的使用情况 top界面默认按cpu的使用降序排序 使用shift+&gt;和shift+&lt;来改变排序的指标 top界面 按x高亮排序的指标 top其他使用技巧 h 显示帮助画面，给出一些简短的命令总结说明 k 终止一个进程 i 忽略闲置和僵死进程。这是一个开关式命令 q 退出程序 r 重新安排一个进程的优先级别 S 切换到累计模式 s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s f或者F 从当前显示中添加或者删除项目 o或者O 改变显示项目的顺序 l 切换显示平均负载和启动时间信息 m 切换显示内存信息 t 切换显示进程和CPU状态信息 c 切换显示命令名称和完整命令行 M 根据驻留内存大小进行排序 P 根据CPU使用百分比大小进行排序 T 根据时间/累计时间进行排序 W 将当前设置写入~/.toprc文件中]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>进程,线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>迎新</category>
      </categories>
      <tags>
        <tag>welcome</tag>
        <tag>hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梁希森林公园]]></title>
    <url>%2F2017%2F04%2F04%2F%E6%A2%81%E5%B8%8C%E6%A3%AE%E6%9E%97%E5%85%AC%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[写博客以来，笔者一直用github作为图床，但当图片的大小超过一定值打开github链接就会直接下载，无法作为url链接，所以将图片暂放微博。 我与梁希先生 人生得意须尽欢 流水潺潺 狗年行大运]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>自然环境</tag>
      </tags>
  </entry>
</search>
