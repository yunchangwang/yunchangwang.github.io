<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机网络——NAT]]></title>
    <url>%2F2018%2F02%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94NAT%2F</url>
    <content type="text"><![CDATA[简介NAT(Network Address Translation)，网络地址转换。NAT可以看成一个开放到公网(全球因特网)上的公用路由器，用来代理一个子网下的所有主机的请求和应答。NAT在转换的时候，会将主机的ip地址和端口号替换成公用路由器的ip地址和端口，并且维护在一张表中进行一一对应，为了将返回的数据应答到唯一的主机上。 作用由于ipv4规则的ip地址消耗殆尽，不可能为所有的主机都分配真正的公网ip，所以很多主机ip地址都是虚拟的ip地址，并且有统一的代理服务器进行消息的请求和应答。NAT的作用就是将私有的ip地址转换成全球因特网承认的ip地址，私有的ip地址有三种：①10.0.0.0~10.255.255.255/8 ②172.16.0.0~172.31.255.255/12 ③192.168.0.0~192.168.255.255/16 这些IP地址是用于私有的网络。NAT使得一个组织局域网中的主机都能互相访问，但是想要访问公网就只有一条出路，这样也可以保证局域网中信息的安全性。 例子假设用户王某坐在家庭主机10.0.0.1傍边，请求域名为 www.bilibili.com (ip地址为112.49.19.4)的web服务器(端口为80)上的一个web页面。主机10.0.0.1为其指派了任意的端口2233，并将请求的报文发送到LAN中。NAT路由器收到该数据请求，为其生成了新的端口号5000，并将ip地址替换成广域网的ip地址138.76.29.7，然后继续想目标服务器请求。具体步骤如下： 10.0.0.1:2233 发送报文 —&gt; LAN LAN —&gt; NAT路由器 —&gt; 替换成138.76.29.7:5000 并维护一张映射表 138.76.29.7:5000 发送请求报文 —&gt; 112.49.19.4:80 返回数据到WAN —&gt; NAT路由器 NAT路由器从维护的映射表中获取私有ip地址 返回数据 —&gt; LAN —&gt; 10.0.0.1:2233 读者以前可能发现，百度的ip地址和主机的ip地址不同，因为一个是公网的，主机的只是私有的ip地址，中间就是利用了NAT。代理服务器，即NAT在跳转的当中可能存在很多个，即一个请求可能通过n个NAT。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>网路协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——DHCP]]></title>
    <url>%2F2018%2F02%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94DHCP%2F</url>
    <content type="text"><![CDATA[简介DHCP(Dynamic Host Configuration)，即动态主机配置协议。由于DHCP具有能将主机连接进一个网络的网络相关方面的自动能力，故它又常被称为即插即用协议。DHCP协议维护了一张表(存放于DHCP服务器)，用来存放现子网中可以分配的ip，如果有主机离开或者接入子网，则DHCP服务器会更新这张表。 作用一旦一个组织获取了子网的ip地址，网络管理员需要给组织中的主机都配置ip(读者可以参考网络攻防——ip地址了解一个组织内主机ip地址配置过程)。DHCP的问世是为了节省网络管理员手动配置主机ip地址的时间。网络管理员只需要配置DHCP，以使某给定主机每次与网络连接时能得到一个相同的ip地址，或者某主机将被分配一个临时的ip地址，该地址每次与网络连接时也许是不同的。 协议的步骤对于一台新到达的主机而言，DHCP协议是一个4个步骤的过程：1234567891.DHCP服务器发现。一台新的主机接入子网时首要的任务时让DHCP服务器发现它。所以主机会在UDP分组中向端口67发送一个DHCP发现报文，并且这个数据时广播的，因为主机现有的情况是不知道DHCP服务器的具体ip地址的。2.DHCP服务器提供。DHCP服务器收到这个报文时，用一个DHCP提供报文向主机作出应答。这边也是使用的广播的形式，因为在子网中可能存在多个DHCP服务器，主机可以根据各个DHCP服务器返回的信息进行择优选择。3.DHCP请求。主机从一个或多个DHCP服务器中挑选一个，并向选中的服务器提供一个DHCP请求报文进行响应。4.DHCP ACK。服务器用DHCP ACK报文对主机请求报文进行响应，证实所要求的参数。 一旦主机完成了以上的4步，交互便完成了，主机也接入了子网，并拥有了子网中唯一的ip地址。 缺陷从移动性的角度看，DHCP确实有不足之处。因为每当节点连接到一个新的子网时，要从DHCP得到一个新的ip地址，当一个移动节点在子网之间移动时，就不能维持与远程应用之间的TCP连接。之后会研究移动IP(在此记录，以便之后补充)。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络攻防——ip地址]]></title>
    <url>%2F2018%2F02%2F18%2F%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E2%80%94%E2%80%94ip%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[这边先预设几个问题 一个组织分配ip地址的过程(涉及到ISP等概念) a,b,c,d,e类的ip地址 如何知道一个主机的子网掩码，它第一跳的路由地址，dns服务器的地址 DHCP动态分配地址 什么是网络地址转换(NAT) ipv4和ipv6的区别 基本概念ip地址目前有ipv4和ipv6两种，这里以ipv4举例。ip地址在整个网络中相当于地址的存在，只有知晓了地址，才能知道向哪里送信，信件又使从哪里发出来的。ipv4地址编码长度为32，即32个比特位，即4个字节，每个比特位只有1或者0，所以ipv4总共有2^32个可能的ip地址。(但是很遗憾，尽管看起来很多，ipv4方式的编码ip已经消耗殆尽，所以ipv6孕育而生) 读者可以使用ipconfig(linux系统使ifconfig)来查看自己的ip地址。读者会发现，显示的ip信息并不是以二进制形式显示，而是十进制。那是为了方便人们阅读，一般使用点分十进制记法书写，然而计算机在交流时仍然只认识二进制记法。1234如：193.32.216.9 的二进制记法是：11000001 00100000 11011000 00001001可以看出以8个比特，即一个字节作为一个分隔 在全球因特网中的每台主机和路由器上的每个接口，必须有一个全球唯一的ip地址(在NAT后面的接口除外，NAT即网络地址转换，之后会提及这个概念)。然而，这些地址不能随意地自由选择，一个接口ip地址的一部分需要由其连接的子网来决定。 标准类别的ip地址ip地址由网络地址和主机地址组成。根据网络地址的比特位数，将ip地址分为A,B或C类网络，网络地址的比特位数分别被限制为8,16或24位，这是一种被称为分类编址的编址方案。 在计算机网络中，读者可能看到形如：233.1.1.0/24的ip地址记法，这是子网地址的写法，其中/24记法有时称为子网掩码，表示32位比特中的最左侧24比特定义了子网地址，即该子网中所有主机分配到的ip地址的前24位都是相同的，即网络地址相同。比如：12一个子网的ip地址为：233.1.1.0/24那么这个子网下的主机的ip地址可能是：233.1.1.1，233.1.1.4 233.1.1.128 ... 在分配子网的时候，不一定使用标准的网络地址。比如一个组织，分类到了一个C类(/24)子网，其仅能容下2^8 - 2 = 254台主机(2^8 = 256，其中的两个地址预留用于特殊的用途)，这对于许多组织来说太小了。然而一个B类(/16)子网可支持多达65534台主机，又太大了。 组织内主机分配ip地址的过程为了获取一块ip地址用于一个组织的子网，网络管理员也许首先会与他的ISP参考百度百科联系，该ISP可能会从已分配给它的更大的地址块中提供一些地址。这里假设ISP自己已被分配了地址块200.23.16.0/20：1234ISP的地址块 200.23.16.0/20 (11001000 00010111 0001)0000 00000000组织0 200.23.16.0/23 (11001000 00010111 000100)0 00000000组织1 200.23.18.0/23 (11001000 00010111 0001001)0 00000000... 加入组织0已经得到了子网地址：200.23.16.0/23，这就表示该组织下的所有主机ip地址都是以11001000 00010111 000100开头的。系统管理员一般手动配置路由器ip地址，主机地址也能手动配置，但是想象一下：如果一个组织下有数以万计的主机，那么系统管理员已哭晕在厕所。所以这里引出另一个概念DHCP(动态主机配置协议，又称即插即用协议)，主机可以自动获取一个临时的ip地址。这也解释了为什么在公司中，主机重启之后主机的ip地址会改变，因为是临时随机分配的。 DHCP笔者认为这个概念可以重新开一个章节，读者可以跳转参考计算机网络——DHCP NAT读者可以跳转参考计算机网络——NAT 如何生动形象解释这里主要解释了ip地址，子网掩码，网关等概念。读者可以参考这篇知乎文章。]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>ip地址</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产问题排查指南——排查思路]]></title>
    <url>%2F2018%2F02%2F12%2F%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[业务指标着手需要提出的是，大部分情况还是业务应用本身引发的问题，所以应从业务指标着手。 查看gc日志 查看gc是否变得频繁，是否出现大量gc甚至full gc，这意味着内存可能发生了问题。此时应保留现场，保存内存dump。 一般应用程序中都有配置gc日志，在/usr/local/logs/gc目录下 需要特别注意，个别major gc可能是正常内存回收，并且gc后的dump也不再体现回收前的内存情况，所以不具有参考性。 一般使用MAT对内存dump进行分析，找出异常的对象，从而判断代码或者业务设计是否有需要修改的地方。 查看业务日志如果gc正常，吞吐量下降的原因可能有两个。一,外部依赖阻塞，二,服务内部资源紧张，请求排队等待。以上两种情况都可能产生蝴蝶效应，服务性能下降，请求排队的同时，内存可能堆积大量对象无法释放，这样就导致出现gc甚至full gc。主要关注两类服务，一,错误量最多的服务，二,第一个耗时异常缓慢的服务，根据错误链路找到异常的触发源。最好的做法就是预防入手，对于应用性能有准确的评估以及可能遭遇的流量高峰有所预测，这样及早做资源扩展。 日志查看手册读者可以查看xqy撰写的生产环境日志指导手册。]]></content>
      <categories>
        <category>生产环境</category>
      </categories>
      <tags>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产问题排查指南——问题排查方法]]></title>
    <url>%2F2018%2F02%2F12%2F%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题排查方法这篇博客主要阐述排查的一些指标，对一些可能造成生产问题的注意点做指导概览。 指标分类基础指标基础指标主要有以下几点： cpu负载：cpu负载高的情况，将直接导致系统吞吐下降。 磁盘：磁盘I/O是否正常，磁盘硬件是否正常。 网络：出网入网流量是否正常，网络是否有波动情况。 中间件负载：中间件负载情况将直接影响调用链路性能。 如果能确保基础指标没有问题，这将大大加快我们排查的效率。例如，当前一段时间内生产网络出现了大幅度的波动，造成了大量服务延迟。如果你没有预先排除网络指标是否正常，而直接排查应用的服务性能问题，那最终将浪费大量的时间和精力。 核心指标线程1234线程数量：多线程并行运行的情况下，存在大量线程切换与上下文信息的同步，cpu主要负责这个。因此线程数量过多，将会直接增加切换与同步的开销，cpu负载增加。top1：无论进程还是线程，都应该 关注cpu占用率最高的那一个，有利于快速排查系统高负载的主要原因。 内存1234567系统内存空闲情况：长时间的低空闲内存，容易在大流量到来时，达到系统警戒阈值，触发OOM Killer，中断应用进程。在其他指标不变的情况下，空闲内存的大小与数据，流量息息相关。大数据与流量高峰都会加大内存开销，遇到服务阻塞，对象会在内存中堆积无法释放，最终导致内存溢出。业务应用内存情况：业务应用会有一块被分配的固定大小的堆内存空间。但配分的大小不一定总是合理的，一个典型的例子是老年代分配内存过大，新生代分配较小，大量的对象在老年代中堆积等待回收，在触发回收前，系统长时间处于空闲内存吃紧状态。 业务指标gc情况直观体现了应用内存当前的健康程度，频繁gc甚至full gc意味着应用内存出现了问题或者没有给应用分配合理的内存空间。 任何时候，日志都是问题排查不可或缺的重要指标。核心指标的异常，最终体现在日志上就是大量的系统或者业务异常，服务错误量激增[调用失败，超时]，执行耗时异常缓慢[一次服务耗时10～100s以上] 扩展读者可能对于OOM Killer这个概念不太了解，可以参考知乎上的这篇形象比喻。]]></content>
      <categories>
        <category>生产环境</category>
      </categories>
      <tags>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产问题排查指南——指标查询指令与方法]]></title>
    <url>%2F2018%2F02%2F12%2F%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E6%8C%87%E5%8D%97%E2%80%94%E2%80%94%E6%8C%87%E6%A0%87%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[生产问题指标cpu中央处理器cpu占用率与负载情况是操作系统繁忙程度的一项总要的指标，它直接影响着应用的吞吐。top命令经常用来监控linux系统状况，也直观展示了系统cpu使用情况。读者可以参考微服务问题定位——top来查看具体的细节。 线程上面的top命令同时展示了各进程cpu使用情况，一般cpu占用量自上而下排序。我们一般关注cpu占用率最高的那个，大部分情况下它就是我们的应用进程。pid列即为进程的id。 $top -Hp pid[十进制进程id] 可以查看指定进程id中各线程的cpu使用情况。 $printf ‘0x%x\n’ nid[十进制线程id] 将线程的id打印为十六进制，目的是给之后的命令提供十六进制的id。 $jstack pid[进程id] | grep ‘nid[十六进制线程id]’ -C5 –colorjstack可以查询jvm进程中的线程栈信息，grep可以从中搜索目标线程信息，可以配合源码分析负载高的原因。 $jstack pid[进程id] &gt; jstack.txt[文件] 当然你可以将当前进程栈信息输出到文件，即我们常说的线程dump，然后进行详细分析。 strace -p nid[线程id] -T strace可以查看操作系统底层的执行情况，包括执行函数和执行耗时等。 内存这里的内存指标分为系统内存和应用内存一般读者可以使用free命令查看系统内存的使用情况，读者可以参考微服务问题定位——free应用内存的查看需要jdk包下的命令： $jmap -heap pid[进程id]jmap可以查看jvm进程的内存分配与使用情况，使用的gc算法等信息。 $jmap -dump:format=b,file=[导出路径] pid[进程id]-dump:format=b,file=可以使用hprof二进制形式输出jvm的heap内容到文件，即我们常说的堆内存dump，然后可以结合MAT[内存分析工具]可以深入分析内存使用情况。注意dump是比较消耗资源的。如果现在系统的内存比较吃紧，磁盘i/o较慢，切忌手动dump，可能成为压死骆驼的最后一根稻草。 -XX:+HeapDumpOnOutOfMemoryError 一般我们会在jvm的启动中添加启动参数，这样发生OOM后jvm能够自动将当时的内存情况dump保留下来。 zip或者gzip 通常dump文件会较大，应该将原dump文件归档到备份地点或者直接移除，以释放这部分磁盘空间占用。在进行下载时也将极大减少带宽开销。 磁盘读者可以参考： 微服务问题定位——df 微服务问题定位——du 网络 dstat 是一个综合的多维度指标命令。视图中有cpu使用情况，磁盘读写，网络情况，分页统计，系统中断与上下文切换统计。这里我们主要关注网络指标net/total- 。recv：入网流量，send：出网流量。当网络传输流量长时间小于实际应用传输数据量大小时，带宽将成为应用性能瓶颈。 ifstat 读者可以参考微服务问题定位——ifstat 日志这里的日志指标分为gc日志和业务日志。 gc日志无论minor gc还是major gc，我们主要关注gc回收实际消耗时间，即为日志中的real，即STW[stop the world]时间，如果实际耗时过长，则严重影响应用性能。 业务日志业务日志一般我们关注调用时间过长或者调用失败的请求，grep ‘[0-9]{3,}ms’ *.log 查看执行耗时3位数以上的服务grep ‘,N’ *.log 查看执行失败的服务]]></content>
      <categories>
        <category>生产环境</category>
      </categories>
      <tags>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在mac上搭建python环境并使用docx模块]]></title>
    <url>%2F2018%2F02%2F12%2F%E5%A6%82%E4%BD%95%E5%9C%A8mac%E4%B8%8A%E6%90%AD%E5%BB%BApython%E7%8E%AF%E5%A2%83%E5%B9%B6%E4%BD%BF%E7%94%A8docx%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[背景之前接手到一个处理word文档的项目，需要读取word内容，并对读取的字符串进行一系列的处理。一开始笔者使用java进行处理，需要引入第三方模块——poi。说实话，这个第三方模块对于word的处理不够完善，第一没有很好的写入方式，第二没有很好的样式处理机制，第三没有封装java的io流，仍然需要笔者手动创建和关闭io资源。 在之后的资料中查询到可以使用python的docx模块很快速处理word文件，使用快捷方便，几行代码就可以实现读写，并且很好的支持word的样式。但是docx模块只支持docx后缀的文档，读者可以先将doc转换docx。 搭建环境搭建平台是macOS10.12.6，一般mac上是自带python的，但是普遍版本较低，目录位置为/Library/Python，以后安装的其他版本也在相同的目录下。 终端$python –version 查看python的版本。 这边可以使用pyenv来管理python的各个版本，笔者这边使用IDE(python编译环境)管理的。如果选择pyenv，请参考。即使不使用pyenv，笔者还是要推荐参考博客中提及的brew——mac的统一依赖包管理器。如果选择IDE管理，请到官网下载PyCharm，这种方式不像pyenv可以使用命令下载python的其他版本，读者可以访问官网下载其他python版本。 IDE在栏目PyCharm下选择Pereferences，如图选择可以切换编译器的python版本：不同的版本切换对代码的编译可能会造成影响。 引入docx模块python处理word也需要引入第三方模块，一般使用pip去下载python的第三方模块。mac里面python自带easy_install。$sudo easy_install pip 输入密码下载pip，笔者强烈建议不要在系统自带的python下折腾，因为mac系统下很多软件都依赖python模块，一些操作可能导致系统的软件打开错误。 读者可以先去官网下载其他版本，然后设置环境变量，sudo vim /etc/profile，编辑添加export PATH=xxxx:$PATH，其中xxxx为下载后python的路径，参考搭建环境。 $python –version 查看版本是否更改，之后执行$sudo easy_install pip，然后在执行$pip install docx模块。 然后读者就可以在当前python版本的目录下看到pip模块和docx模块了。之后在PyCharm中切换python的版本，在编写的代码中引入docx模块即可。读者可以参考官网手册]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm——新生代,老年代和持久代]]></title>
    <url>%2F2018%2F02%2F11%2Fjvm%E2%80%94%E2%80%94%E6%96%B0%E7%94%9F%E4%BB%A3-%E8%80%81%E5%B9%B4%E4%BB%A3%E5%92%8C%E6%8C%81%E4%B9%85%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[新生代，老年代和永久代java中堆是jvm所管理的最大的一块内存空间，主要用于存放各种类的实例对象。jvm中内存的分配有如下公式： 堆 = 年轻代 + 老年代 年轻代 = eden space(新生代) + from survivor + to survivor 年轻代默认值保持为堆大小的1/15，特点是对象更新速度快，在短时间内产生大量的死亡对象，并且要产生连续可用的空间。所以使用复制清楚算法和并行收集器进行垃圾回收，对年轻代的垃圾回收称作初级回收(minor gc)。 年轻代的工作机制jvm，年轻代中每次只会使用eden space和其中一块survivor区域来为程序服务，所以无论如何总有一块survivor区域总是空闲的。对象在 eden 中初始化，在经过一次minor gc后，如果对象还存活着，即被引用着，并且能够被另外一块survivor区域所容纳，则使用复制算法将这些仍然还存活的对象复制到另外一块survivor区域中。 年轻代如何变成老年代初始化过程与上面一致，在eden中。在minor gc之后，如果对象还存活着，这些对象的年龄+1，当超过某个值(默认为15)这些对象进入老年代。 老年代的gc堆内存的老年代不同于现实生活，老年代中的对象个个都是从survivor中熬过来的，所以老年代中的类不是那么容易死亡的。因此，full gc(又称major gc)发生的次数没有minor gc那么频繁，并且一次full gc要比minor gc时间要更长。标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。 持久代此外还有一个持久代，用于存放静态文件，如java类定义(相当于模版，不是实例对象)、方法、本地方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如hibernate等，在这种时候需要设置较大的持久代空间来存放这些运行过程中新增的类 。持久代大小通过-XX:MaxPermSize=进行设置。 补充有的虚拟机并没有持久代，java8开始持久层也已经被彻底删除了，取代它的是另一个内存区域也被称为元空间。想要参考更多，读者可以参考这篇博客 jvm配置项jvm配置项可以根据程序的实际要求来配置，如各个代的比例等。这边原本应该用表格的形式展示，但是hexo在渲染markdown的表格语法时不支持，待到作者修复这个bug后进行更改。1234567891011121314151617181920212223242526* -Xms 初始堆大小。如：-Xms256m* -Xmx 最大堆大小。如：-Xmx512m * -Xmn 新生代大小。通常为 Xmx 的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + 1 个 Survivor，即 90% * -Xss JDK1.5+ 每个线程堆栈大小为 1M，一般来说如果栈不是很深的 话， 1M 是绝对够用了的。 * -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2， 则新生代占整个堆空间的1/3，老年代占2/3 * -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。 即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10 * -XX:PermSize 永久代(方法区)的初始大小 * -XX:MaxPermSize 永久代(方法区)的最大值 * -XX:+PrintGCDetails 打印 GC 信息 * -XX:+HeapDumpOnOutOfMemoryError 让虚拟机在发生内存溢出时 Dump 出当前的内 存堆转储快照，以便分析用]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五行相生——第二章]]></title>
    <url>%2F2018%2F02%2F04%2F%E4%BA%94%E8%A1%8C%E7%9B%B8%E7%94%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[太阳已经落山了，迷迷重雾之后，一处红火若隐若现。 “哟，您来啦，来人准备上房。” “怎么，你在这里身份好像很尊贵？” 粘土想探探铄金的身世。”楼上准备了热水，你可以洗漱一番。” 铄金避而不答，引着粘土到了这里的最高层。 没有想象的靡靡之音，有的而是琴箫入耳，一曲琵琶。”这里到是一片高雅，并不是你说的那种地方？” “这里的姑娘都是卖艺不卖身，而且各个身怀武艺，是江湖中用来交换情报的地方。” “哦，你倒是挺熟的？” “因为现在站在你面前的是这儿的头。” 只见铄金狡黠一笑。 “先沐浴更衣吧。明日一早再出发不迟。” 然而粘土迟迟未动，”你…你先回避一下。” 软儒的声音再次传来，粘土此刻羞红了脸，背对身去。”我俩都是女子，为何还如此害羞？” “谁说女子就…就不会？我就知道世上还有女子可以相爱。” 铄金并没有回应，粘土此时转过身来，只见一头金发披散开来，在烛光下熠熠生辉，显的背后更加白皙光泽。”你…你怎先脱去了衣物？” “这一路赶来，我也好几天没有洗漱了，正好今天洗个痛快。” “你先进去吧！” 只见粘土仍背对着，不敢回头。铄金慢慢移步过来，”今晚只备了一份水，只能一起喽。” 说罢便脱去了粘土的衣服，”你，快快转过身去！” 粘土双臂抱在胸前喝斥道。”好好好，我转过去，你且自行脱去，我先进去了。”]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>武侠</tag>
        <tag>传记</tag>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五行相生——第一章]]></title>
    <url>%2F2018%2F02%2F04%2F%E4%BA%94%E8%A1%8C%E7%9B%B8%E7%94%9F%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[“喂喂喂，听说没有，江南城里发生了命案，死的是当地的地头蛇，听说是一剑封喉，连凶手的身影都没有看到。” 此时茶坊里人们正在议论纷纷，三日前在江南城中发生的大案到了这里也不过众人的茶余饭后。 茶坊中间的桌子上，一位客人正喝着茶，此人一头金色短发，腰间挂着一把鱼肠短剑，静静听着旁人的纷纷议论。 “这位姑娘，可否容在下在此就座？” 一句温柔的声音打破了女子的静静偷听，抬头望去，面前站着身着长衫的女子，长发垂条，手持一把褐色长杖，惊堂木挂于腰间。”为何就座我这里？” 金发女子保持了应有的警觉性，尖锐的眼神中似乎发问道。”在下看姑娘一身正气，似乎旁边也没有合适之地。” 长发女子眉间弱气了几分，话语也软儒了几分。”唉，坐吧。” 两人都静静喝着茶，一时间气氛陷入诡异。 “在下粘土，请问姑娘芳名？” 粘土长舒一口气，心想终于打破了这尴尬的局面。”在下铄金，正北上办一件事，才会路经此地，我看姑娘文文弱弱，为何来此荒野之地？” “在下受一位故友之托去北方边城之地送信，方圆没有人家，炎炎夏日，来此歇脚。” 铄金看着面前的女孩，脸上尽是风霜，绳鞋上的双脚也都尽是污垢，就知一路受尽苦楚，但也掩不住女子坚毅的气息与姣好的面容，就知再过不久女子便要远行，心生怜悯之情。但是内心挣扎，迟迟没有开口。 “姑娘请留步。” 铄金还是留住了粘土，”今晚可已有住处？” “此去早已知晓，以天为被，以地为床。” 粘土回头莞尔一笑。铄金对眼前的女子更生钦佩之情，”再往北10里，有家客栈，处于迷雾之中，少有人见，在下正要到那投宿，不知姑娘有意同行？” “当真！” 粘土心中甚是兴喜，没有沐浴半月有余，正好要去去尘垢。 “你我现在同行，不必如此生分，你叫我铄金便可。” “那铄金唤我粘土吧，看我长你几岁，叫姐姐也尚可。” 粘土的嬉笑着调戏到。”哦，粘土为何如此信任我，你可知今晚我们投诉的地方是哪儿？” 看着一脸疑惑的粘土，铄金突然凑近贴着耳朵缓缓说道：”乃风花雪夜之所，粘土就不怕我把你卖了？” 看着粘土的防备，长杖紧贴身前，铄金哈哈大笑向前走去。粘土紧跟其后，知道被骗了，心有不甘。”我看你天性纯真，但防人之心不可无，以后不要因人其表就被他人骗了去。” 铄金停下严肃道，粘土的眼中倒映出一抹深深，弱弱道：”但是我知道你不是坏人！” “哦，你难道懂窥心之术？” 粘土并未回答，只是跟了上去。 两人并排向前，身后是拉长的斜影。]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>武侠</tag>
        <tag>传记</tag>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux编辑器——vim]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E7%BC%96%E8%BE%91%E5%99%A8%E2%80%94%E2%80%94vim%2F</url>
    <content type="text"><![CDATA[VIM编辑器背景vi在mac下严格意义上讲不是一个简单的命令，而是unix系列下的自带的编译器，笔者没记错发明这编译器的家伙是个大胡子，一直致力于软件开源的维护和倡导$vi filename 这是开始编译一个文件，有时候需要switch user 即sudo 简介这边笔者不做过多的介绍请看维基百科这里的vim编辑器是vi的一种升级版 编辑文件之前说过基本用法:$vim filename，这边还有其他的用法$vim +line filename 编辑文件，并定位到第line行$vim + filename 编辑文件，并定位到最后一行$vim +/pattern filename 编辑文件，并定位到第一个匹配的位置 关闭文件这边需要提及vim的模式(之后补充，这边提及)，打开文件后需要进入输入模式或者其他模式，才能使用一些命令，退出模式后才能关闭文件一般按esc按钮来推出vim的模式，然后输入:来选择退出的方式:q 退出:wq 保存并退出:q! 不保存并退出:w 保存但没有退出，可以继续编辑:w! 强行保存退出后就回到命令窗口界面了，当然也可以直接编辑模式退出如：编辑模式按ZZ即可 模式i 在当前光标所在的字符前面转为输入模式a 在当前光标所在的字符后面转为输入模式o 在当前光标所在行的下方新建一行，并转为输入模式I 在当前光标所在行的行首转为输入模式A 在当前光标所在的行尾转为输入模式O 在当前光标所在的上方新建一行，并转为输入模式以上的命令必须是非编辑状态或者非其他的状态，然后按下相应的按键进入编辑模式 相关命令移动很简单，就是键盘上的上下左右键w 移至下一个单词词首，中文一般以标点为准跳动e 移至当前或下一个单词词尾b 移至当前或者前一个单词词首nw 移动n个单词 跳转0 跳转到光标所在的行首^ 跳转到行首的第一个非空白字符$ 绝对的行尾nG 跳转到第#行gg 跳转到第一行行首G 跳转到最后一行行首 翻页ctrl+f 向下翻一屏ctrl+b 向上翻一屏ctrl+d 向下翻半屏ctrl+u 向上翻半屏 删除x 删除光标所在处的单个字符nx 删除光标所在处及后面共n个单词dd 删除光标所在的行ndd 删除光标所在行及后面共n行 粘贴p: 如果删除或复制为整行内容，则粘贴至光标所在行的下方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的后面P: 如果删除或复制为整行内容，则粘贴至光标所在行的上方，如果复制或删除的内容为非整行，则粘贴至光标所在字符的前面以上命令只作用于vim编辑器内部，外面复制的内容不行 复制用法和d命令的用法相同，将d替换成y 替换r 替换单个字符，但是好像不支持中文nr 光标后n个字符全部替换R 进入替换模式，可直接替换光标所在的字符 撤销编辑操作u 在非模式状态下，撤销前一次的编辑操作nu 直接撤销最近的n次编辑操作 选取v 进入选取模式，按字符选取，最多到光标所在的行V 进入选取模式，但是按矩形进行选取 查找:/pattern 根据匹配的字符查找:?pattern 同上n 下一个N 上一个 查找并替换headline,footline s#PATTERN#string#gn,$s#wyc#王鋆昌#g 替换第n行开始到最后一行中每一行所有wyc为王鋆昌参考 编辑多个文件vim file1 file2:next 切换到下一个文件:prev 切换到上一个文件:last 切换到最后一个文件:first 切换到第一个文件:q 退出当前文件:qa 全部退出 未完待续vim的使用远非及此，之后还有有涉及会及时补充]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令——crontab]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94crontab%2F</url>
    <content type="text"><![CDATA[crontab作用自定义定时任务笔者一般用这个命令来提醒事项，适用于基本每天执行的事项 option参数-e 编辑cron脚本文件，可以指定编辑器，默认是vi编辑器-l 列出当前用户下的cron任务-u 指定cron在哪个用户下执行，默认是当前用户 使用实例$brontab -e 执行后跳到编辑器你可以在编辑器中书写cron命令，一般的格式是 command content上面格式中的 从左至右分别表示分，时，日，月份和年份，content就是自定义的命令了如果命令较多，你甚至可以写在一个shell脚本中，执行脚本即可比如：15 9 * command sh xxx.sh 每天早上9:15执行xxx.sh脚本 扩展一般用$cron -e编辑的脚本，笔者也不知道保存到哪里去了，一般笔者都是写完之后直接执行的比如：crontab test.cron即可，test.cron即为编写好的脚本，内容形式与上面的一致 实用价值了解敏捷开发的读者应该知道，部门中可能存在一些管理方式，需要每天执行任务，比如早晨的定时晨会，比如记录一天内的工作时间，等等读者可以使用outlook来提醒，或者手机的定时闹钟，笔者选择用crontab命令来显示高逼格列出了笔者mac中每天执行的任务，将多个cron任务编辑在同一个.cron文件内，执行就能实现多个任务的并存发现cron任务content可以直接命令，也可以shell脚本执行]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令——awk]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94awk%2F</url>
    <content type="text"><![CDATA[awk用法awk ‘{pattern + action}’ {filenames} 使用方式awk -F 分隔符 ‘{command操作}’awk -f awk-script-file input-file(s)上面的命令比较有意思，awk-script-file是脚本文件，一般比较复杂的awk命令可以写成一个脚本，然后操作到input-file(s)文件上 内置变量ARGC 命令行参数个数ARGV 命令行参数排列ENVIRON 支持队列中系统环境变量的使用FILENAME awk浏览的文件名FNR 浏览文件的记录数FS 设置输入域分隔符，等价于命令行 -F选项NF 浏览记录的域的个数NR 已读的记录数OFS 输出域分隔符ORS 输出记录分隔符RS 控制记录分隔符 使用实例在xqy的日志使用手册中，有统计所有抛出非业务异常的服务的命令，相信很多开发不知道运行的原理，在此我做一下说明：cat common-service-digest.log | grep ‘N,’ | awk -F ( ‘{print $2}’ | awk -F ) ‘{print $1}’ | awk -F , ‘{!a[$1”.”$2”.”$3]++;}END {for (j in a) print j,a[j]}’这个命令比较长，你可以分开进行执行，比如:1.cat common-service-digest.log | grep ‘N,’ 查看调用失败的日志2.awk -F ( ‘{print $2}’ 以 （作为分隔符分割日志行，并打印分隔片区2比如:日志记录:[(tax,ICustomerSettingManageService,getAreaCodeBatch,Y,12ms)] (traceId=84ec429fbff64c5bbc43347c8cc72257)被分隔为:[(tax,ICustomerSettingManageService,getAreaCodeBatch,Y,12ms)](traceId=84ec429fbff64c5bbc43347c8cc72257)最后输出:tax,ICustomerSettingManageService,getAreaCodeBatch,Y,24ms)]3.awk -F ) ‘{print $1}’ 以 ）作为分隔符分割日志行，并打印分隔片区1最后输出:tax,ICustomerSettingManageService,getAreaCodeBatch,Y,12ms4.awk -F , ‘{!a[$1”.”$2”.”$3]++;} 以 ,作为分隔符分割日志行，并以$1”.”$2”.”$3为键统计5.最后end进行循环输出参考 说明当中涉及到xqy的日志业务和图片，所以不部署到github]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令——sed]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94sed%2F</url>
    <content type="text"><![CDATA[sed系统mac系统用的是原生的bsd系列，而一般的linux系统用的是gnu系统，所以两者在某些命令是有区别的，sed命令位列其中 区别mac上sed的添加和插入文本比较奇葩，需要如此:$sed “$line a\ (在\后要加一个空格，然后另起一行，再写需要添加的那一行新的)>$value（需要添加新一行的内容）>“ $filename(文件名)同上，sed i的使用方式亦然 gnu-sed如果无法适应原生bsd系列，可以下载gnu-sed，这个时候brew神器又用到了，直接下载然后配置环境变量即可:$brew install gnu-sed之后的叙述都是基于gnu-sed说明 option参数-n ：使用安静(silent)模式，在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上，但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来-e ：直接在命令列模式上进行 sed 的动作编辑-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)-i ：直接修改读取的文件内容，而不是输出到终端 方法a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法 实例$sed ‘2a 字符串’ filename —— 第二行下一行添加字符串$sed ‘2i 字符串’ filename —— 第二行上一行添加字符串以上的命令只能作用在缓存的文件中，其实真实的文件内容并没有被改变$sed ‘2a 字符串’ -i filename —— 这样可以直接修改文件了$sed ‘1,2d’ -i filename —— 删除文件1-2行的内容sed与nl联合使用可以进行关键字查找:$nl filename | sed -n ‘/关键字/p’sed支持正则表达的搜索和替换:$sed ‘s/正则表达式 or 普通字符串/新字符串/g’ -i filename[其他用法:]https://www.cnblogs.com/ggjucheng/archive/2013/01/13/2856901.html]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令——补充]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E2%80%94%E2%80%94%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[常用命令(补充)grep用法grep [-acinv][–color=auto] ‘查找字符串’ filename option参数-c 统计查找字符在文件中出现的次数-i 忽略大小写-v 反向查找，即显示不在查找内的行，但是根据记录日志的习惯，很少会使用–color=auto 对查找的字符进行颜色显示 联合使用ls -l |grep -i filename 列出指定文件/文件夹的属性ps -ef|grep tomcat/java 列出指定的进程信息 find用法find [PATH] [option] [action] option参数-mtime n 其中n为数字，表示n天以前，查找n天之前修改过的文件-user name 查找指定所有者的文件-size [+-size] 查重比size大/小的文件 使用$find . -mtime 0 来查找当天修改过的文件，一般可以筛选当天有记录的日志 taroption参数-c ：新建打包文件-t ：查看打包文件的内容含有哪些文件名-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中-j ：通过bzip2的支持进行压缩/解压缩-z ：通过gzip的支持进行压缩/解压缩-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来-f filename ：filename为要处理的文件-C dir ：指定压缩/解压缩的目录dir 使用实例$tar -tzvf xxx.zip 查看指定压缩文件里面的文件内容$tar -zxvf xxx.zip 解压缩指定文件$tar -cvf xxx.tar dir 压缩指定文件夹$tar -czvf xxx.tar.gz dir 以gzip的格式进行压缩如何使用解压缩命令的option操作，最终还是要看压缩文件的格式的，如-z一般用来支持.gz结尾的压缩包 kill用法kill [选项] [参数] option参数-a：当处理当前进程时，不限制命令名和进程号的对应关系-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称 -p：指定kill 命令只打印相关进程的进程号，而不发送任何信号-s &lt;信息名称或编号&gt;：指定要送出的信息-u：指定用户 常用的信号编号HUP 1 终端断线 INT 2 中断（同 Ctrl + C） QUIT 3 退出（同 Ctrl + \） TERM 15 终止 KILL 9 强制终止 CONT 18 继续（与STOP相反， fg/bg命令） STOP 19 暂停（同 Ctrl + Z）在mac中18是STOP，19是CONT]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令文件上传与下载]]></title>
    <url>%2F2018%2F01%2F31%2Flinux%E5%91%BD%E4%BB%A4%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[文件上传下载搭建实践环境这边使用笔者自己的电脑和windows电脑进行实践。 利用ssh打通windows和mac打开mac的系统偏好设置中的共享，一般情况下没有界面展示的，需要使用搜索查找共享， 然后勾选远程登陆，选择全部用户可访问 在windows上使用ssh连接mac，填写相应的用户名和密码即可 安装要支持sz，rz两个命令，系统需要安装lrzsz，一般的linux系统是自带的，这里使用mac进行实验，需要安装。参考 使用sz filename，即从系统上下载文件到本地，filename是系统中你选择下载的文件rz -b，将本地的文件以二进制的传递方式上传到系统服务器，一般推荐使用二进制传输方式其他参考]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo防止敏感数据部署]]></title>
    <url>%2F2018%2F01%2F30%2Fhexo%E9%98%B2%E6%AD%A2%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[hexo防止敏感数据部署原理熟悉hexo的读者都知道，hexo的部署一般执行如下:$hexo clean$hexo g$hexo d如果不按照顺序执行这三步，读者会发现即使增添了page，部署时git也不会显示增添文件的记录，github上也没有提交的代码记录其实这涉及到hexo的部署原理，hexo clean 会清除之前构建的代码，具体就是public文件夹；hexo g 会重新生成，这样读者添加的page也就构建在其中，此时新的public文件夹会生成；hexo d 就是将hexo g 改变的文件提交到github上所以不执行clean和generate是不会真正意义上修改remote上的代码 敏感数据敏感数据这里指的就是涉及公司业务的文章，因为hexo d 会将文章直接部署到github上，这样就全部公开化了这边最好是本地可以访问，github无法访问你的敏感数据，这篇文章的目的就在此 利用.gitignore熟悉git的读者，应该都知道可以使用.gitignore文件忽略一些提交网上有些说修改.npmignore文件配置(hexo的根目录下)可以起到效果，经过测试发现没有起到作用，所以转而到git寻求解决方案一般执行如下(当前目录为hexo根目录):$cd .deploy_git git push的代码都在此文件夹下$vim .gitignore增加如下配置:page name/ page的名称，hexo n page创建命令中你定义的文章名，如:linux命令性能监控及优化/.gitignore 自己本身但是笔者发现代码虽然没有提交到github上，但是hexo博客上有这个新建的标题，点击访问也是github默认的404页面(因为hexo g过程中一定会将文章标题写入hexo中，.gitignore只能做到忽略提交) 自定义404上面的问题引入了这个小结，github默认的404页面会让读者误以为是网站的问题，其实是不想公开化，所以你可以自定义404页面具体的步骤如下(hexo的根目录下):$hexo n page 404 source目录下生成404目录index.md中增加配置: layout: false //是否使用布局文件 comments: false //是否有评论 permalink: /404 //设置链接然后按照hexo部署步骤上传到github上，然后再访问敏感文章链接会跳转到自定义的404页面其实根本问题是github上没有代码，但是hexo在generate时将目录还是写入了导致，但是笔者找不到解决忽略写入的方法]]></content>
      <categories>
        <category>hexo部署</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令性能监控及优化]]></title>
    <url>%2F2018%2F01%2F30%2Flinux%E5%91%BD%E4%BB%A4%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[性能监控和优化toptop freefree vmstat用来统计虚拟内存的使用情况，这边涉及到linux物理内存和虚拟内存的知识点，其实之前我们也提到过，虚拟内存即交换区 option参数-a：显示活跃和非活跃内存-f：显示从系统启动至今的fork数量-m：显示slabinfo-n：只在开始时显示一次各字段名称-s：显示内存相关统计信息及多种系统活动数量delay：刷新时间间隔。如果不指定，只显示一条结果count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷-d：显示磁盘相关统计信息-p：显示指定磁盘分区统计信息-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）默认单位为K（1024 bytes）-V：显示vmstat版本信息 使用实例$vmstat 5 6 在docker上进行试验，在6秒内采集5次数据 说明Procs（进程）：r: 运行队列中进程数量b: 等待IO的进程数量Memory（内存）：swpd: 使用虚拟内存大小free: 可用内存大小buff: 用作缓冲的内存大小cache: 用作缓存的内存大小Swap：si: 每秒从交换区写到内存的大小so: 每秒写入交换区的内存大小IO：（现在的Linux版本块的大小为1024bytes）bi: 每秒读取的块数bo: 每秒写入的块数系统：in: 每秒中断数，包括时钟中断cs: 每秒上下文切换数CPU（以百分比表示）：us: 用户进程执行时间(user time)sy: 系统进程执行时间(system time)id: 空闲时间(包括IO等待时间),中央处理器的空闲时间 以百分比表示wa: 等待IO时间 需要关注的指标如果 r经常大于 4 ，且id经常少于40，表示cpu的负荷很重如果bi，bo 长期不等于0，表示内存不足如果disk 经常不等于0， 且在 b中的队列 大于3， 表示 io性能不好]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2018%2F01%2F30%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用命令pwd没什么可说的，当前不知道处于那个目录下时，pwd即可 mvmv命令是将一个文件移动到指定的目录，但是在linux可以用来重命名文件 moremore是具有翻页功能的cat命令 lessless是一个可以前后分页浏览文件的命令，相比more更加具有弹性 whichwhich用于查找命令包所在的路径，没有配置在环境变量中的命令是搜索不到的，因为which只会搜索path下的命令，echo $PATH可以查看 lsls命令还是很常用的，不做过多描述ls g* 模糊列出文件列表，即将g开头的文件列出 unzip和gzipunzip主要用于解压.zip压缩文件 unzip xxx.zipgzip file1 file2 … 文件打包压缩为.gz的形式对于文件夹的打包或者其他的压缩格式请使用tar命令 whatis和man$whatis command 用于显示命令使用的描述$man command 以使用手册的形式显示]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——jmap]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94jmap%2F</url>
    <content type="text"><![CDATA[jmap使用场景 内存溢出，线上程序运行时内存越来越大，用jmap dump出堆内存的信息，然后进行相关分析 内存的真实使用大于预期，这是因为设计不合理导致冗余的对象存在内存中，用jmap来查看内存中的对象，分析是否有存在的必要 jvm优化，利用jmap来查看整个堆的使用情况，根据老年代和新生代的使用比例来划分jvm的各个区域 使用实例在使用jmap连接进程时，启动的jvm版本和jdk版本要一一对应，毕竟jmap是jdk下的命令包$ps -ef | grep java 查找系统的java进程$jmap -heap pid 打印指定进程堆的摘要信息，包括gc算法 参数说明 Heap Configuration: 堆配置信息 MinHeapFreeRatio 在堆的使用率小于MinHeapFreeRatio(%)的时候进行收缩，当Xmx=Xms的时候此配置无效MaxHeapFreeRatio 在堆使用率大于MaxHeapFreeRatio(%)的时候进行扩展，当Xmx=Xms的时候此配置无效MaxHeapSize 堆的最大空间NewSize 新生代的大小MaxNewSize 最大的新生代的大小OldSize 老年代的大小NewRatio 老年代和新生代的比例SurvivorRatio 新生代中Eden和和Survivor区的比例PermSize 永久代的大小MaxPermSize 久代的最大内存G1HeapRegionSize 使用G1垃圾收集的区间 Heap Usage: 堆的使用信息 New Generation (Eden + 1 Survivor Space): 新生代的大小（Eden区加一个Survivor区的空间信息 capacity 总内存used 已使用内存free 剩余内存13.823827124993642% used 使用内存占比 Eden Space: Eden区的大小 capacityusedfree15.178337946947952% used From Space: 第一个Surivivor区的空间信息 capacityusedfree2.984432830624237% used To Space: 第二个Survivor区的空间信息 capacityusedfree0.0% used concurrent mark-sweep generation: CMS垃圾收集占用的空间信息 capacityusedfree75.36470666527748% used Perm Generation: 永久代的空间信息 capacityusedfree47.5915253162384% used 其他功能参考链接]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——jstack]]></title>
    <url>%2F2018%2F01%2F29%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94jstack%2F</url>
    <content type="text"><![CDATA[jstack功能查看运用程序jvm的堆栈情况，可以找出线程的运行情况，从而排查一些隐患或者服务卡顿的问题 具体说明jstack用于打印出给定的java进程id或者core file或者远程调试服务的java堆栈信息，如果是在64位机器上，需要指定选项-J-d64如果java程序崩溃会生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松知道java程序是如何崩溃和在程序何处发生问题。 option参数-F 当jstack -l pid 没有响应的时候强制打印栈信息-l 长队列，打印关于锁的附加信息-m 打印java和native c/c++框架的所有栈信息 命令格式jstack [option] pidjstack [option] executable corejstack [option] [server-id@]remote-hostname-or-IP 命令格式说明executable core 产生core dump的java可执行文件remote-hostname-or-IP 远程debug服务的主机名或ipserver-id 唯一id,假如一台主机上多个远程debug服务 使用实例一般需要与top命令联用，使用top命令找出异常的进程(一般是cpu使用异常的进程)通过top -Hp pid来定位该进程下各线程的cpu使用情况再通过jstack pid命令打印该线程对应的堆栈情况 扩展 在top命令中，已经获取到了占用cpu资源较高的线程pid，将该pid转成16进制的值(在线转换)，在thread dump中每个线程都有一个nid，找到对应的nid即可 什么是java core和heap dump文件，参考]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitbook目录折叠]]></title>
    <url>%2F2018%2F01%2F28%2Fgitbook%E7%9B%AE%E5%BD%95%E6%8A%98%E5%8F%A0%2F</url>
    <content type="text"><![CDATA[gitbook目录折叠背景在编写gitbook的时候发现目录的数量比较庞大的时候显得杂乱无章因为章节比较多的时候全展开，很难有目的地寻找所以笔者去寻求了解决之道，用来折叠目录，笔者在网上找到了一个插件可以解决这个问题 插件插件网站上面还有其他gitbook使用的插件 使用参考个性化配置gitbook，同理你可以在里面添加需要使用的插件，如图book.json在根目录下，即与SUMMARY.md同级$ cd到gitbook目录$ npm install gitbook-plugin-toggle-chapters重新build serve即可]]></content>
      <categories>
        <category>gitbook</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在本地搭建gitbook]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BAgitbook%2F</url>
    <content type="text"><![CDATA[本地搭建gitbook介绍gitbook更加适用于书写使用手册，不太适合书写一些博客和总结，所以笔者最近在做一些迁移的工作，将之前gitbook上的内容迁移到当前的博客上但是gitbook对于我们的工作还是有适用的地方的 先决条件安装nodejs是先决条件，因为我们需要npm去下载gitbook在mac电脑上，有brew工具的可以直接下载:$brew search nodejs 搜索包仓库中是否有nodejs$brew install nodejs 有就可以直接下载你也可以选择去官网上下载最新的nodejs压缩包，解压配置环境变量后即可使用 搭建这里默认大家的电脑上已经安装好了nodejs按照步骤执行以下命令:$npm install gitbook-cli -g 下载gitbook客户端包$gitbook –version 查看gitbook的版本，测试是否可以使用命令$cd /users/Desktop 切换到一个目录，这里笔者切换到了桌面$mkdir gitbook 创建gitbook目录，这个目录就是用来初始化的其实上面的两步读者可以手动完成$gitbook init 初始化gitbook$gitbook build 构建，一般有内容更新时要构建$gitbook serve 开启服务，默认在4000端口监听http://localhost:4000 开启你的访问之路吧！ 问题笔者之前在windows上搭建过，出现了一些问题，build的时候总是报错在github官方issues中，官方表示这个是已知的gitbook的bug，高版本的gitbook会出现这个bug如果你遇到相同的问题，请参考:解决方法解决方法是点赞和喝彩最多的]]></content>
      <categories>
        <category>gitbook</category>
      </categories>
      <tags>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——du]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94du%2F</url>
    <content type="text"><![CDATA[du功能du命令也是查看使用空间的，但是与df命令不同的是 du命令是对文件和目录磁盘使用的空间的查看 option参数-a或-all 显示目录中个别文件的大小-b或-bytes 显示目录或文件大小时，以byte为单位-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和-k或–kilobytes 以KB(1024bytes)为单位输出-m或–megabytes 以MB为单位输出-s或–summarize 仅显示总计，只列出最后加总的值-h或–human-readable 以K，M，G为单位，提高信息的可读性-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过-L&lt;符号链接&gt;或–dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件–exclude=&lt;目录或文件&gt; 略过指定的目录或文件-D或–dereference-args 显示指定符号链接的源文件大小-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位-l或–count-links 重复计算硬件链接的文件 实例$du 显示当前目录下面子目录的目录大小和总和$du dir/filename 显示指定目录或者文件$du #1 #2 同时显示多个，空格隔开]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——df]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94df%2F</url>
    <content type="text"><![CDATA[功能用来检查服务器文件系统的磁盘空间占用情况，可以获取硬盘被占了多少空间，目前还剩下多少空间等信息。 option 参数-a 显示全部文件系统列表-h 以方便查阅的方式显示，即带有单位的形式-H 相当于-h，但是换算的方式变更，这里1k=1000-i 显示node信息-k 区块为1024字节，即1Kb为一个区块-l 只显示本地文件系统-m 区块为1048576字节，即1Mb为一个区块–no-sync 忽略sync命令-P 输出格式为POSIX–sync 在取得磁盘信息前先执行sync命令-T 文件系统类型 选择参数–block-size=&lt;区块大小&gt; 指定区块的大小-t &lt;文件系统类型&gt; 只显示选定文件系统的磁盘信息-x &lt;文件系统类型&gt; 不显示选定文件系统的磁盘信息 使用实例第一列 显示各文件系统第二列 显示文件系统的共有多少块，这里以512B为一块，换算后即可知道文件系统大小第三列 显示已经使用的磁盘大小第四列 显示可用的磁盘大小关于其他的使用方式，读者可以参考cnblogs了解。这边需要说明：已使用的+可使用的 != 总块数，因为缺省的每个分区都预留了少量空间供管理员使用，所以即使普通用户的空间已满，管理员依然可以登录系统解决相关问题。]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>磁盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——ifstat]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94ifstat%2F</url>
    <content type="text"><![CDATA[ifstat功能监控系统的流量 安装ifstat不是系统自带的命令，所以需要进行安装。mac系统的读者可以在终端使用命令：$brew install ifstat进行安装。当然系统首先要安装brew(mac系统中的包下载工具)，读者可以参考简书进行安装。 option 参数-l 监测环路网络接口(lo)，缺省情况下不会显示，所谓的环路网络可认为是localhost(127.0.0.1)。读者可以参考知乎了解相关的解释。-a 监测系统所有的网络，比加上-l参数还多一个plip0的接口信息(所谓的并口)-z 隐藏流量是无的接口，排查问题时排除无用端口-i 指定要监测的接口,后面跟网络接口名-s 等于加-d snmp:[comm@][#]host[/nn]] 参数，通过SNMP查询一个远程主机-t 在每一行的开头加一个时间 戳,，告诉我们具体的时间-T 报告所有监测接口的全部带宽，和-i联用来指定端口-S 在同一行更新流量状态，不喜欢屏幕滚动的可以使用读者可以使用man top或者top -help查看完整的参数列表。更多详细的命令，读者可参考其他命令了解。 扩展如何只查看网卡的流量情况，ifstat足矣。详细的流量情况需使用iftop命令，系统依旧不会自带需要下载，mac下的下载方式与ifstat一致。读者可以参考实例了解用法。]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——free]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94free%2F</url>
    <content type="text"><![CDATA[free功能 显示系统使用和空闲的内存情况，包括物理内存和交互区内存(swap)和内核缓冲区内存 option参数 -b 以Byte为单位显示内存使用情况 -k 以KB为单位显示内存使用情况 -m 以MB为单位显示内存使用情况 -g 以GB为单位显示内存使用情况 -o 不显示缓冲区调节列 -s&lt;间隔秒数&gt; 持续观察内存使用状况 -t 显示内存总和列 -V 显示版本信息 读者可以使用man free或者free -help查看完整参数列表。 样例 这边关注第二行的swap的used指标，如果使用的值较大，则表示系统的内存处于不够使用的情况 为何swap used是一个指标 swap又称为交换分区，当系统的内存小于额定值的时候，内核(OS)会将系统的一部分物理内存释放出来用于当前线程的使用，一般是很久没有操作过的程序会被释放，释放的物理内存被放入到交换区，然后等当前线程执行完毕，内存富余时重新放入物理内存。12345678910例如：物理内存，交换区，当前线程，进程x(目前存在于物理内存中)1.当前线程 向 物理内存 申请执行所需的内存空间2.物理内存 发现没有空间了 查找到 进程x 很久没有操作过3.物理内存 将 进程x 释放到 交换区4.物理内存 说 嘿 当前线程 你可以进来执行了5.当前线程 执行完毕 嘿 我执行完了 让那哥们进来吧6.物理内存 将 进程x 重新载入以上就是简略的过程。]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>内存相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——strace]]></title>
    <url>%2F2018%2F01%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94strace%2F</url>
    <content type="text"><![CDATA[功能 在linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。 strace可以跟踪到一个进程产生的系统调用，包括参数，返回值，执行消耗的时间。 option参数 -c 统计每一系统调用的所执行的时间,次数和出错的次数等 -d 输出strace关于标准错误的调试信息 -f 跟踪由fork调用所产生的子进程 -tt 在输出中的每一行前加上时间信息,微秒级， 时间格式：17:22:58.345879 -p pid 跟踪指定的进程pid 以上命令一般都是与-p联用 读者可以使用man strace或者strace -help查看完整的参数列表。 strace使用 strace的使用一般在top命令之后，top命令是用来查看占用cpu异常的进程的。读者可以参考微服务定位——top。 找到异常的进程后，使用命令：top -Hp pid[进程id]进入进程，找到执行异常的那个线程。使用命令：strace -p nid[线程id] -T来查看底层的调用情况。 在此贴出网上的一些参考链接 strace实例 strace实例2 样例贴图 笔者在此贴出strace命令显示的底层执行的信息： 1234567891011$strace cat /dev/nullexecve(&quot;/bin/cat&quot;, [&quot;cat&quot;, &quot;/dev/null&quot;], [/* 22 vars */]) = 0brk(0) = 0xab1000access(&quot;/etc/ld.so.nohwcap&quot;, F_OK) = -1 ENOENT (No such file or directory)mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)...每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>进程,线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务问题定位——top]]></title>
    <url>%2F2018%2F01%2F26%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94top%2F</url>
    <content type="text"><![CDATA[功能显示当前系统正在执行的进程的相关信息，包括进程ID、 内存占用率 、CPU占用率等 option 使用参数-b 进入批处理模式 相当于不停地执行top命令显示信息-c 显示完整的command 位于信息的最后一列-i &lt;时间&gt; 设置间隔时间 如-i 5设置5秒钟刷新一次top信息-u &lt;用户名&gt; 显示指定用户的信息 -p &lt;进程号&gt; 显示指定进程的信息 -n &lt;次数&gt; 循环显示的次数 读者可以使用man top或者top -help查看完整的参数列表。 例图 说明 第一行: 13:40:29 — 当前系统时间10 day，2:32 — 机器从开机到目前为止运行的时长20 users — 登陆的用户有20个load average — 分别对应1mins,5mins,15mins的负载情况(根据一定的算法得到的值，load average／cpu数量&gt;=5说明系统超负荷) 第二行 Tasks 系统进程数total — 当前系统进程269个running — 正在运行的1个sleeping — 睡眠的268个stopped — 停止的0个zombie — 僵尸进程0个 第三行 0.1% us — 用户空间占用CPU的百分比0.0% sy — 内核空间占用CPU的百分比0.0% ni — 改变过优先级的进程占用CPU的百分比99.9% id — 空闲CPU百分比0.0% wa — IO等待占用CPU的百分比0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比0.0% si — 软中断（Software Interrupts）占用CPU的百分比 第四行 Mem 物理内存total — 物理内存总量 8GBfree — 空闲的内存used — 正在使用的内存buff/cache — 缓存的内存(used表示现在系统内核控制的内存数，free表示还未进入内核控制的内存数，used还包括了停止使用但可能被重用的内存，所以used使用完的内存不会返还给free，所以free的内存数一定越来越少) 第五行 Swap 交换区total — 交换区总量used — 使用的交换区总量free — 空闲交换区总量cached — 缓冲的交换区总量(swap used经常变化的话说明内存已经不够使用了)(系统可使用的内存近似为第四行的free+buff/cache+第五行的cache)读者可以参考 参考链接了解 进程状态监控各项指标 PID — 进程idUSER — 进程所有者PR — 进程优先级NI — nice值，负值表示高优先级，正值表示低优先级VIRT — 进程使用的虚拟内存总量，单位kb，VIRT=SWAP+RESRES — 进程使用的、未被换出的物理内存大小，单位kb，RES=CODE+DATASHR — 共享内存大小，单位kbS — 进程状态，D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程%CPU — 上次更新到现在的CPU时间占用百分比%MEM — 进程使用的物理内存百分比TIME+ — 进程使用的CPU时间总计，单位1/100秒COMMAND — 进程名称（命令名/命令行） top交互执行top命令之后即进入top信息展示界面，可以使用命令行进行交互 top界面 按1显示多核cpu的使用情况 top界面默认按cpu的使用降序排序 使用shift+&gt;和shift+&lt;来改变排序的指标 top界面 按x高亮排序的指标 top其他使用技巧 h 显示帮助画面，给出一些简短的命令总结说明 k 终止一个进程 i 忽略闲置和僵死进程。这是一个开关式命令 q 退出程序 r 重新安排一个进程的优先级别 S 切换到累计模式 s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s f或者F 从当前显示中添加或者删除项目 o或者O 改变显示项目的顺序 l 切换显示平均负载和启动时间信息 m 切换显示内存信息 t 切换显示进程和CPU状态信息 c 切换显示命令名称和完整命令行 M 根据驻留内存大小进行排序 P 根据CPU使用百分比大小进行排序 T 根据时间/累计时间进行排序 W 将当前设置写入~/.toprc文件中 说明在top命令界面中，几乎不使用交互命令，在排查问题时，一般紧盯cpu使用高的线程即可。]]></content>
      <categories>
        <category>微服务问题定位</category>
      </categories>
      <tags>
        <tag>linux命令</tag>
        <tag>微服务</tag>
        <tag>进程,线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>迎新</category>
      </categories>
      <tags>
        <tag>welcome</tag>
        <tag>hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梁希森林公园]]></title>
    <url>%2F2017%2F04%2F04%2F%E6%A2%81%E5%B8%8C%E6%A3%AE%E6%9E%97%E5%85%AC%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[写博客以来，笔者一直用github作为图床，但当图片的大小超过一定值打开github链接就会直接下载，无法作为url链接，所以将图片暂放微博。 我与梁希先生 人生得意须尽欢 流水潺潺 狗年行大运]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>自然环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跆拳道]]></title>
    <url>%2F2016%2F06%2F13%2F%E8%B7%86%E6%8B%B3%E9%81%93%2F</url>
    <content type="text"><![CDATA[跆拳道 人不疯狂枉少年]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>校园</tag>
      </tags>
  </entry>
</search>
